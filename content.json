{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"Hello World","slug":"hello-world","date":"2023-01-27T05:01:22.874Z","updated":"2023-01-27T15:10:15.603Z","comments":true,"path":"2023/01/27/hello-world/","link":"","permalink":"http://example.com/2023/01/27/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Python+Docker实现人脸识别远程监控系统","slug":"Python+Docker实现人脸识别远程监控系统","date":"2022-05-06T16:00:00.000Z","updated":"2023-01-28T06:25:17.097Z","comments":true,"path":"2022/05/07/Python+Docker实现人脸识别远程监控系统/","link":"","permalink":"http://example.com/2022/05/07/Python+Docker%E5%AE%9E%E7%8E%B0%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E8%BF%9C%E7%A8%8B%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"说明​ 本项目包括服务端程序和客户端程序。服务端使用Python OpenCV库实现人脸识别功能，并将添加上识别结果的视频流通过TCP发送给客户端，且支持将上述功能程序封装为Docker容器；客户端程序通过IP+端口接入服务端，接收视频流，实时查看人脸识别结果。客户端可与服务端断开接入后重新连接，不影响服务端功能。 项目文件 tcpsend.py（服务端程序） tcpreceive.py（客户端程序） requirements.txt（项目依赖） train.py（人脸识别模型训练程序） trainer.yml（人脸识别模型） haarcascade_frontalface_alt2.xml（分类器） Dockerfile（构建Docker镜像所需文件） 项目源码tcpsend.py1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import socketimport cv2import sysimport osimport numpy as npip###address = (&#x27;ip&#x27;, 5555) # 服务端地址和端口ser = socket.socket(socket.AF_INET, socket.SOCK_STREAM)ser.bind(address)ser.listen(5)# 阻塞式print(&#x27;waiting。。。&#x27;)conn, addr = ser.accept()print(&#x27;建立连接...&#x27;)print(&#x27;连接对象：&#x27;, addr)cap = cv2.VideoCapture(0)# cap = cv2.VideoCapture(0)frames_num=cap.get(7)print(&#x27;视频总帧数：&#x27;,frames_num)print(&#x27;发送目标...&#x27;)count = 0#######加载训练数据集文件recogizer = cv2.face.LBPHFaceRecognizer_create()recogizer.read(&#x27;./trainer.yml&#x27;)names = []warningtime = 0#准备识别的图片def face_detect_demo(img): gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) # 转换为灰度 face_detector = cv2.CascadeClassifier(&#x27;./haarcascade_frontalface_alt2.xml&#x27;) face = face_detector.detectMultiScale(gray, 1.1, 5, cv2.CASCADE_SCALE_IMAGE, (100, 100), (300, 300)) # face=face_detector.detectMultiScale(gray) for x, y, w, h in face: cv2.rectangle(img, (x, y), (x+w, y+h), color=(255, 144, 30), thickness=2) # blue,green,red # cv2.circle(img,center=(x+w//2,y+h//2),radius=w//2,color=(0,255,0),thickness=1) # 人脸识别 ids, confidence = recogizer.predict(gray[y:y + h, x:x + w]) # print(&#x27;标签id:&#x27;,ids,&#x27;置信评分：&#x27;, confidence) if confidence &gt; 80: cv2.putText(img, &#x27;unkonw&#x27;, (x + 10, y - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.75, (255, 144, 30), 2) else: cv2.putText(img, &#x27;dong&#x27;, (x + 10, y - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.75, (255, 144, 30), 2) # cv2.imshow(&#x27;result&#x27;, img) # print(&#x27;bug:&#x27;,ids) return imgdef name(): path = &#x27;./dataset/&#x27; # names = [] imagePaths = [os.path.join(path, f) for f in os.listdir(path)] for imagePath in imagePaths: name = str(os.path.split(imagePath)[1].split(&#x27;.&#x27;, 2)[1]) names.append(name)####name()while True: flag, frame = cap.read() frame = face_detect_demo(frame) # frame = cv2.resize(frame, (1280, 720)) # cv2.imshow(&#x27;send&#x27;, frame) cv2.waitKey(1) count += 1 # 数据打包有很多方式，也可以用json打包 img_encode = cv2.imencode(&#x27;.jpg&#x27;, frame)[1] data_encode = np.array(img_encode) str_encode = data_encode.tostring() try: conn.sendall(str_encode) except : conn, addr = ser.accept() tcpreceive.py123456789101112131415161718192021222324252627282930import socketimport sysimport cv2import numpy as npimport timeaddress = (&#x27;ip&#x27;, 5555) # 服务端地址和端口cli = socket.socket(socket.AF_INET, socket.SOCK_STREAM)try: cli.connect(address) # 尝试连接服务端except Exception:ip print(&#x27;[!] Server not found or not open&#x27;) sys.exit()frame_count = 1while True: time1 = time.time() if frame_count == 1 else time1 trigger = &#x27;ok&#x27; cli.sendall(trigger.encode()) data = cli.recv(1024*1024*20) image = np.frombuffer(data, np.uint8) image = cv2.imdecode(image, cv2.IMREAD_COLOR) try: cv2.imshow(&#x27;video&#x27;, image) except: continue cv2.waitKey(1) end_time = time.time() time2 = time.time() print(image.shape[:2], int(frame_count / (time2 - time1))) frame_count += 1cli.close() train.py12345678910111213141516171819202122232425262728import osimport cv2 as cvfrom PIL import Imageimport numpy as npdef getImageAndLabels(path): facesSamples = [] # 储存人脸数据 ids = [] # 尺寸姓名数据 imagePaths = [os.path.join(path, f) for f in os.listdir(path)] # 储存图片信息 face_detector = cv.CascadeClassifier(&#x27;D:/Python/python3.9.8/Lib/site-packages/cv2/data/haarcascade_frontalface_alt2.xml&#x27;) # 加载分类器 for imagePath in imagePaths: # 遍历列表中的图片 PIL_img = Image.open(imagePath).convert(&#x27;L&#x27;) # 打开图片，灰度化(PIL有九种模式：1,L,P,RGB,RGBA,CMYK,YCbCr,YCbCr,I,F) img_numpy = np.array(PIL_img, &#x27;uint8&#x27;) # 将图片转换为数组，以黑白深浅 faces = face_detector.detectMultiScale(img_numpy) # 获取图片人脸特征 id = int(os.path.split(imagePath)[1].split(&#x27;.&#x27;)[0]) # 获取每张图片的id和姓名 for x, y, w, h in faces: ids.append(id) facesSamples.append(img_numpy[y:y+h, x:x+w]) print(&#x27;id:&#x27;, id) print(&#x27;fs:&#x27;, facesSamples) return facesSamples, idsif __name__ == &#x27;__main__&#x27;: path = &#x27;./dataset/&#x27; # 图片路径 faces, ids = getImageAndLabels(path) # 获取图像数组和id标签数据和姓名 recognizer = cv.face.LBPHFaceRecognizer_create() # 加载识别器 recognizer.train(faces, np.array(ids)) # 训练 recognizer.write(&#x27;./trainer/trainer.yml&#x27;) # 保存文件 requirements.txt1234numpy==1.21.5Pillow==9.1.0opencv-contrib-python==4.5.5.64opencv-python==4.5.5.64 Dockerfile12345678FROM python:3.7-slimADD ./facerecognitionserver /codeWORKDIR /codeRUN apt-get updateRUN apt-get install -y libgl1-mesa-glxRUN apt-get install -y libglib2.0-devRUN pip install -r requirements.txtCMD [&quot;python&quot;,&quot;/code/tcpsend.py&quot;]","categories":[],"tags":[]}],"categories":[],"tags":[]}