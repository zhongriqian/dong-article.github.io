{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"Docker","slug":"Docker","date":"2023-01-27T14:42:14.618Z","updated":"2023-01-27T15:14:42.416Z","comments":true,"path":"2023/01/27/Docker/","link":"","permalink":"http://example.com/2023/01/27/Docker/","excerpt":"","text":"概述123java —— apk —— 发布到应用商店 —— 用户下载apk —— 安装即可用java —— jar —— jar+环境打包成镜像 —— 发布到Docker仓库 —— 用户下载镜像 —— 直接就可以运行jar+环境打包的镜像，就好像windows系统的镜像，安装后里面有操作系统也有初始应用 1Docker核心思想：隔离 历史优势1234虚拟机技术缺点：1.资源占用十分多2.冗余步骤多3.启动很慢 1234容器化技术容器化技术不是模拟的一个完整的操作系统容器内的应用直接运行在宿主机的内核上，容器自己没有内核，轻便每个容器互相隔离，每个容器内都有一个自己的文件系统，互不影响 基本组成12345678910镜像（image）：docker镜像好比一个模板，可以通过这个模板来创建容器最终服务运行或项目运行就是在容器中容器（container）：通过镜像来创建容器后，利用容器技术，独立运行一个或一组应用启动、停止、删除等基本命令仓库（repository）：存放镜像的地方官方：Docker Hub阿里云等也有容器服务（配置镜像加速） 底层原理12Docker是一个Client-Server结构的系统，Docker的守护进程运行在主机上，通过Socket从客户端访问Docker-Server接收到Docker-Client的指令，就会执行这个命令 Docker安装12#查看状态systemctl status docker Docker卸载12345678#卸载docker ceapt purge docker-ce#卸载docker eeapt purge docker-ee#删除docker镜像、容器、数据卷文件rm -rf /var/lib/dockerapt autoremove -y --purge docker.io Docker常用命令帮助命令123docker version #显示docker版本信息docker info #显示docker系统信息，包括镜像和容器的数量docker 命令 --help #帮助命令 镜像命令12345678910docekr images #查看所有本地主机上的镜像REPOSITORY 镜像的仓库源TAG 镜像的标签IMAGE ID 镜像的IDCREATED 镜像的创建时间SIZE 镜像的大小-a #列出所有镜像-q #只显示镜像ID 123docker search 镜像名 #搜索镜像--filter=STARS=3000 #搜索出来的镜像就是STARS大于3000的 1docker pull 镜像名 #下载镜像 12345docker rmi 镜像名/ID #删除镜像-f #强制全部删除docker rm -f $(docker ps -aq) #删除所有容器docker rmi -f $(docker images -aq) #删除所有镜像 容器命令1234567891011docker run [可选参数] image #新建容器#参数说明--name=Name 容器名字-d 后台方式运行-it 使用交互式运行，进入容器查看内容-p 指定容器端口 -p IP：主机端口：容器端口 -p 主机端口：容器端口 #映射 -p 容器端口-P 随机指定端口 12345docker ps #列出所有运行的容器-a #列出当前正在运行的容器+历史运行过的容器-n=？ #显示最近创建的？个容器-q #只显示容器ID 12exit #停止并退出容器Ctrl+P+Q #容器不停止退出 123docker rm 容器ID #删除容器，但不能删除正在运行的容器-f #强制删除所有容器 1234docker start ID #启动容器docker restart ID #重启容器docker stop ID #停止当前正在运行的容器docker kill ID #强制停止当前容器 其他常用命令12docker run -d 镜像名 #后台启动容器#docker容器使用后台运行，就必须要有一个前台进程，docker发现没有应用，就会自动停止，docker ps 会发现容器没在运行 12345docker logs ID #显示日志-f #动态显示-t #带时间戳--tail ？ #显示？条日志 1docker top ID #查看容器中进程信息 1docker inspect ID #查看镜像的元数据 12docker exec -it ID /bin/bash #进入当前正在运行的容器，进入容器后开启一个新的终端docker attach ID #进入当前正在运行的容器，进入容器后进入正在执行的终端，不会启动新的进程 1docker cp ID:容器内路径 目的主机路径 #查看当前主机目录 容器交互命令12复制主机文件到容器内：docker cp 主机文件路径 容器ID:容器路径 使用阿里云镜像加速器12345678[root@localhost ~]# mkdir -p /etc/docker[root@localhost ~]# tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;&#123; &quot;registry-mirrors&quot;: [&quot;https://9cpn8tt6.mirror.aliyuncs.com&quot;]&#125;EOF[root@localhost ~]# systemctl daemon-reload[root@localhost ~]# systemctl restart docker Docker镜像联合文件系统 UnionFS123是一种分层、轻量级并且高效的文件系统对文件系统的修改作为一次提交来一层一层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下一次同时加载多个文件系统，但从外面看，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录 docker镜像加载原理123docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统就是UnionFSbootfs（boot file system）主要包含bootloader和kernel，bootloader主要是引导加载kernel，linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs。这一层与我们的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统就会卸载bootfs。rootfs（root flie system），在bootfs之上。包含的就是典型Linux系统中的/dev，/proc，/bin，/etc等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Cento等。 123虚拟机的CentOS都是几个G的，但包含CentOS的Docker镜像只有几百M对于一个精简的OS，rootfs可以很小，只需要包含最基本的命令，工具和程序库就可以，因为底层直接用主机的Kernel，自己只需要提供rootfs就可以。不同的linux发行版，bootfs基本是一致的，rootfs会有差别，因此不同的发行版可以公用bootfs。 12Docker镜像都是只读的，当容器启动时，一个新的可写层被加载到镜像的顶部这一层就是我们通常说的容器层，容器之下的是镜像曾 commit镜像提交容器生成一个新的镜像 1docker commit -m=&quot;描述信息&quot; -a=&quot;作者&quot; [容器ID] [目标镜像名:tag] save命令&#x2F;镜像另存为12docker save 镜像ID/镜像名称 &gt; 保存路径如：docker save 12342141 &gt; /root/image.tar 12最好使用镜像名称保存，这样在其他服务器导入镜像后，镜像名和之前一样，且能通过docker images找到此镜像而使用镜像ID保存，在其他服务器导入镜像后，通过docker images找不到此镜像 导入镜像1docker load &lt; 路径 虚悬镜像在构建镜像时出现错误，导致镜像的repository和tag都是none，即为虚悬镜像这种镜像应及时清理 1234# 显示所有虚悬镜像dcoker image ls -f dangling=true# 删除所有虚悬镜像docker image prune Docker数据卷1数据持久化 12指定路径挂载docker run -it -v 主机路径:容器内路径 具名挂载和匿名挂载123456789101112131415匿名挂载：docker run -it -v 容器内路径会生成一个随机生成的卷名具名挂载：docker run -it -v [卷名:容器内路径]两种方式都会将容器内路径挂载到/var/lib/docker/volumes/卷名/_datadocker run -it -v [卷名:容器内路径]:roreadonlydocker run -it -v [卷名:容器内路径]:rwreadwrite设置了ro，就只能从外部路径改变容器文件内容 容器间挂载12docker run -it --name=&quot;容器名01&quot; --volume-from [其他容器名02] [镜像名]挂载之后，01和02同步挂载到主机路径 Portainer12Portainer是一个可视化的容器镜像的图形管理工具，利用Portainer可以轻松构建，管理和维护Docker环境。https://www.portainer.io/ 123官网Linux环境安装#Install Portainer with Docker on Linuxhttps://docs.portainer.io/v/ce-2.9/start/install/server/docker/linux 12登录https://localhost:9443 CIG1CAdvisor+influxDB+Granfana，监控收集+存储数据+展示图表 1docker stats命令可以查看当前宿主机上的所有容器的CPU、内存以及网络流量等数据，但数据资料是实时的，不能存储，没有健康指标过线预警等功能 1234CAdvisor是一个容器资源监控工具，包括容器的内存、CPU、网络IO、磁盘IO等监控，同时提供WEB页面用于查看容器的实时运行状态。但默认只存储2分钟的数据，而且只针对单物理机。主要功能： 展示主机和容器两个层次的监控数据 展示历史变化数据 1influxDB是用Go语言编写的一个开源分布式时序、事件和指标数据库，无需外部依赖 1Granfana是一个开源的数据监控分析可视化平台，支持多种数据源配置（influxDB等）和丰富的插件机模板功能，支持图标权限控制和报警。 compose部署CIG1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# docker-compose.ymlversion: &#x27;3.1&#x27;volumes: grafana_data: &#123;&#125;services: influxdb: image: tutum/influxdb:0.9 restart: always environment: - PRE_CREATE_DB=cadvisor ports: - &quot;8083:8083&quot; - &quot;8086:8086&quot; volumes: - ./data/influxdb:/data cadvisor: image: google/cadvisor links: - influxdb:influxsrv command: -storage_driver=influxdb -storage_driver_db=cadvisor -storage_driver_host=influxsrv:8086 restart: always ports: - &quot;8080:8080&quot; volumes: - /:/rootfs:ro - /var/run:/var/run:rw - /sys:/sys:ro - /var/lib/docker/:/var/lib/docker:ro grafana: user: &quot;104&quot; image: grafana/grafana user: &quot;104&quot; restart: always links: - influxdb:influxsrv ports: - &quot;3000:3000&quot; volumes: - grafana_data:/var/lib/grafana environment: - HTTP_USER=admin - HTTP_PASS=admin - INFLUXDB_HOST=influxsrv - INFLUXDB_PORT=8086 - INFLUXDB_NAME=cadvisor - INFLUXDB_USER=root - INFLUXDB_PASS=root 123456789浏览cDdvisor收集服务http://ip:8080浏览influxdb存储服务http://ip:8083浏览grafana展示服务http://ip:3000默认账户密码都是admin注：关闭防火墙并开放所需的端口 Granfana配置12345添加influxDB数据源并配置URL: http://InfluxDB:8086Database: cadvisorUser: rootPassward： root Dockerfiledockerfile——dockerimage——dockercontainer dockerfile指令12345678910111213141516FROM #指定基础镜像MAINTAINER #镜像是谁写的，姓名+邮箱RUN #镜像构建时需要运行的命令ADD #添加环境需要的文件WORKDIR #镜像的工作目录VOLUME #挂载目录EXPOSE #端口配置CMD #指定容器启动时要运行的命令，只有最后一个生效，可被代替 CMD [&quot;ls&quot;,&quot;-a&quot;] docker run [name] ls -lENTRYPOINT #指定容器启动时要运行的命令，可以追加命令 ENTRYPOINT [&quot;ls&quot;,&quot;-a&quot;] docker run [name] -l ONBUILD #当构建一个被继承DockerFile时运行ONBUILD指令COPY #类似ADD，将我们文件拷贝到镜像中ENV #构建的时候设置环境变量 dockerfile build1docker build -f [dockerfile文件路径] -t [镜像名:tag] . 发布镜像1docker login -u [用户名] -p[密码] 1docker push [镜像名] Docker网络123456docker run -d -p --name=&quot;容器名称&quot; [镜像名]进容器内安装iprout2和iputils-ping和net-toolsapt update &amp;&amp; apt install -y iproute2apt install iputils-pingapt install net-toolsdocker exec -it 容器名称 ip addr 123456789docker容器内查看网络信息1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever6: eth0@if7: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0 valid_lft forever preferred_lft forever 12345虚机内查看网络信息7: veth6b5716f@if6: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP group default link/ether 8e:0c:a1:21:80:2e brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet6 fe80::8c0c:a1ff:fe21:802e/64 scope link valid_lft forever preferred_lft forever 1docker exec -it [已运行的容器名] ping [其他已运行容器的IP地址] veth-pair1 –link1234docker exec -it [已运行的容器名] ping [其他已运行容器名]未经 --link 设置，是不能ping通的docker run -d -P --name=&quot;tomcat03&quot; --link tomcat02 tomcat配置完tomcat03能ping通tomcat02，但02不能ping通03 network123docker network lsdocker network inspect [网络ID]docker network rm [容器ID] 网络模式1234bridge：桥接none：不配置网络host：和宿主机共享网络container：容器网络连通 自定义网络1docker0的局限：默认域名不能访问，--link可以配置 12docker network create --driver bridge --subnet 192.167.0.0/16 --gatway 192.167.0.1 mynet设置自定义网络 12docker run -d -P --name tomcat-net-01 --net mynet tomcat--net 设置容器的网络 1自定义网络没有docker0的局限 网络连通123处于网段1的容器接入网段2docker network connect mynet tomcat01设置完之后相当于一个容器两个IP redis集群部署实战123456789101112131415161718192021for port in $(seq 1 6); \\do \\mkdir -p /mydata/redis/node-$(port)/conftouch /mydata/redis/node-$(port)/conf/redis.confcat &lt;&lt; EOF &gt;/mydata/redis/node-$(port)/conf/redis.confport 6379bind 0.0.0.0cluster-enabled yescluster-config-file nodes.confculster-node-timeout 5000cluster-announce-ip 172.38.0.1$(port)cluster-announce-port 6379cluster-announce-bus-port 16379appendonly yesEOFdonedocker run -p 637$(port):6379 -p 1637$(port):16379 --name redis-$(port) \\-v /mydata/redis/node-$(port)/data:/data \\-v /mydata/redis/node-$(port)/conf/redis.conf:/etc/redis/redis.conf \\-d --net redis --ip 172.38.0.1$(port) redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf 12345678910111213mkdir -p /mydata/redis/node-6/conftouch /mydata/redis/node-6/conf/redis.confvim /mydata/redis/node-6/conf/redis.confport 6379bind 0.0.0.0cluster-enabled yescluster-config-file nodes.confcluster-node-timeout 5000cluster-announce-ip 172.38.0.16cluster-announce-port 6379cluster-announce-bus-port 16379appendonly yes 1234docker run -p 6376:6379 -p 16376:16379 --name redis-6 \\-v /mydata/redis/node-6/data:/data \\-v /mydata/redis/node-6/conf/redis.conf:/etc/redis/redis.conf \\-d --net redis --ip 172.38.0.16 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf 12345678进入容器docker exec -it redis-1 /bin/shredis-cli --cluster create 172.38.0.11:6379 172.38.0.12:6379 172.38.0.13:6379 172.38.0.14:6379 172.38.0.15:6379 172.38.0.16:6379 --cluster-replicas 1redis-cli -ccluster nodes Docker compose123456789定义、运行多个容器；YAML file 配置文件；命令；Dockerfile中定义app的运行环境，使它能在任何地方运行；docker-compose.yml中定义组成app的服务；docker-compose up启动项目；一个容器相当于一个服务；一组互相关联的容器组成一个项目，compose自动化管理这一组容器 compose和swarm区别123Docker Swarm 和 Docker Compose 一样，都是 Docker 官方容器编排项目，但不同的是：Docker Compose 是一个在单个服务器或主机上创建多个容器的工具Docker Swarm 则可以在多个服务器或主机上创建容器集群服务 安装123456#下载curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.5/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose#授权sudo chmod +x /usr/local/bin/docker-compose#查看版本docker-compose --version 试测12341.写应用程序：app.py2.写Dockerfile，把应用和环境打包成构建镜像文件3.写docker-compose.yml，定义整个服务4.启动compose项目，docker compose up 停止12在compose文件所在路径下docker-compose stop yaml规则1https://docs.docker.com/compose/compose-file/compose-file-v3/ 123456789101112131415161718192021#版本，与docker版本对应version:&quot;&quot;#服务service： 服务1： #服务配置 images： container_name: ports: volumes: network： depends_on: environment: command: 服务2： #服务配置 服务3： #服务配置#其他配置volumes：networks： Docker swarm123swarm 集群管理和编排node 就是一个docker节点，多个节点组成一个集群service 任务，可以在管理节点或工作节点来运行 1docker swarm --help 1dcoker swarm init --help 12#创建集群docker swarm init --advertise-addr [IP] 1234#获取令牌docker swarm join-token managerdocker swarm join-token worker在任意管理节点输入上方的命令，就能获取供其他节点使用的加入集群命令(manager：以管理节点加入；worker：以工作节点加入) 12#集群节点查询docker node ls Raft1http://thesecretlivesofdata.com/raft/ 动态扩缩容12345docker service update --replicas [数量] [服务名]#数量小于当前服务数量时会终止多出的#加入集群的所有节点，没被分配到服务的节点也可以访问到其他节点的服务docker service scale [服务名]=[数量]docker service rm [服务名]","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2023-01-27T05:01:22.874Z","updated":"2023-01-27T15:10:15.603Z","comments":true,"path":"2023/01/27/hello-world/","link":"","permalink":"http://example.com/2023/01/27/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}