{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://zhongriqian.github.io","root":"/"},"pages":[{"title":"归档","date":"2023-01-28T07:48:11.000Z","updated":"2023-01-28T08:03:42.358Z","comments":true,"path":"archives/index.html","permalink":"http://zhongriqian.github.io/archives/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-01-28T07:54:36.000Z","updated":"2023-01-28T08:31:25.384Z","comments":true,"path":"tags/index.html","permalink":"http://zhongriqian.github.io/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2023-01-28T07:54:51.000Z","updated":"2023-01-28T08:31:23.746Z","comments":true,"path":"categories/index.html","permalink":"http://zhongriqian.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"IGH_DC同步程序设计方案及接口函数介绍","slug":"IGH-DC同步程序设计方案及接口函数介绍","date":"2023-02-26T16:00:00.000Z","updated":"2023-03-04T10:47:36.105Z","comments":true,"path":"2023/02/27/IGH-DC同步程序设计方案及接口函数介绍/","link":"","permalink":"http://zhongriqian.github.io/2023/02/27/IGH-DC%E5%90%8C%E6%AD%A5%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88%E5%8F%8A%E6%8E%A5%E5%8F%A3%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"设计方案 从站作为参考时钟 激活从站的DC功能。 使用ecrt_slave_config_dc(ec_slave_config_t *sc, uint16_t assign_activate, uint32_t sync0_cycle, int32_t sync0_shift, uint32_t sync1_cycle, int32_t sync1_shift) 指定一个从站作为参考时钟，一般选用接入主站拓扑中的第一个带有DC功能的从站 使用ecrt_master_select_reference_clock(ec_master_t *master, ec_slave_config_t *sc) 在每个通信周期里，将主站时钟，以及其他从站时钟都同步到参考时钟 每个周期，主站首先获取本地时钟 使用ecrt_master_application_time(ec_master_t *master, uint64_t app_time) 然后主站获取参考时钟，并将主站时钟同步到参考时钟 使用ecrt_master_reference_clock_time(ec_master_t *master, uint32_t *time) 最后将参考时钟发送给其他从站，使其他从站时钟同步到参考时钟 使用ecrt_master_sync_slave_clocks(ec_master_t *master) 主站作为参考时钟 激活从站DC功能 使用ecrt_slave_config_dc(ec_slave_config_t *sc, uint16_t assign_activate, uint32_t sync0_cycle, int32_t sync0_shift, uint32_t sync1_cycle, int32_t sync1_shift) 将第一个带DC功能的从站设置为参考时钟 使用ecrt_master_select_reference_clock(ec_master_t *master, ec_slave_config_t *sc) 每个周期里，将参考时钟的值改为主站时钟的值，并将改后的参考时钟发送给其他从站 主站首先获取本地时钟 使用ecrt_master_application_time(ec_master_t *master, uint64_t app_time) 修改参考时钟，改为主站时钟的值 使用ecrt_master_sync_reference_clock_to(ec_master_t *master, uint64_t sync_time) 或ecrt_master_sync_reference_clock(ec_master_t *master) 将参考时钟发送给其他从站，使其他从站时钟同步到参考时钟 使用ecrt_master_sync_slave_clocks(ec_master_t *master) 接口函数 ecrt_slave_config_dc 1234567891011121314151617181920212223242526272829/** Configure distributed clocks. * 配置分布式时钟（DC） * * Sets the AssignActivate word and the cycle and shift times for the sync * signals. * 设置激活字以及同步信号的周期和偏移时间 * * The AssignActivate word is vendor-specific and can be taken from the XML * device description file (Device -&gt; Dc -&gt; AssignActivate). Set this to zero, * if the slave shall be operated without distributed clocks (default). * 激活字是厂商指定的，可以在ESI(Device -&gt; Dc -&gt; AssignActivate)中查询。 * 激活字是用于设置从站的0x980和0x981寄存器中的值，这两个寄存器正是同步信号控制器相关的寄存器。 * 大多数厂商的激活字都设置为0x0300，根据两个寄存器中每一位的置位功能分析出，设置0x0300功能为激活SYNC0信号。 * （0x0500为激活SYNC1信号，0x0700为激活SYNC0和SYNC1信号） * 后四个参数用于设置SYNC0和SYNC1信号的周期和偏移时间，单位纳秒。 * * This method has to be called in non-realtime context before * ecrt_master_activate(). * * \\attention The \\a sync1_shift time is ignored. */void ecrt_slave_config_dc( ec_slave_config_t *sc, /**&lt; Slave configuration. */ uint16_t assign_activate, /**&lt; AssignActivate word. */ uint32_t sync0_cycle, /**&lt; SYNC0 cycle time [ns]. */ int32_t sync0_shift, /**&lt; SYNC0 shift time [ns]. */ uint32_t sync1_cycle, /**&lt; SYNC1 cycle time [ns]. */ int32_t sync1_shift /**&lt; SYNC1 shift time [ns]. */ ); ecrt_master_select_reference_clock 12345678910111213141516/** Selects the reference clock for distributed clocks. * 为分布式时钟选择参考时钟 * * If this method is not called for a certain master, or if the slave * configuration pointer is NULL, then the first slave with DC functionality * will provide the reference clock. * 如果此方法没有被主站调用，或从站指针为NULL，则默认选择第一个具有DC功能的从站提供参考时钟 * * \\return 0 on success, otherwise negative error code. * 返回0为成功，失败则返回负数错误代码 */int ecrt_master_select_reference_clock( ec_master_t *master, /**&lt; EtherCAT master. EtherCAT主站*/ ec_slave_config_t *sc /**&lt; Slave config of the slave to use as the * reference slave (or NULL). 作为参考时钟的从站*/ ); ecrt_master_application_time 12345678910111213141516171819202122232425/** Sets the application time.设置应用时间 * * The master has to know the application&#x27;s time when operating slaves with * distributed clocks. The time is not incremented by the master itself, so * this method has to be called cyclically. * * * \\attention The time passed to this method is used to calculate the phase of * the slaves&#x27; SYNC0/1 interrupts. It should be called constantly at the same * point of the realtime cycle. So it is recommended to call it at the start * of the calculations to avoid deviancies due to changing execution times. * * The time is used when setting the slaves&#x27; &lt;tt&gt;System Time Offset&lt;/tt&gt; and * &lt;tt&gt;Cyclic Operation Start Time&lt;/tt&gt; registers and when synchronizing the * DC reference clock to the application time via * ecrt_master_sync_reference_clock(). * * The time is defined as nanoseconds from 2000-01-01 00:00. Converting an * epoch time can be done with the EC_TIMEVAL2NANO() macro, but is not * necessary, since the absolute value is not of any interest. */void ecrt_master_application_time( ec_master_t *master, /**&lt; EtherCAT master. */c uint64_t app_time /**&lt; Application time. */ ); ecrt_master_reference_clock_time 12345678910111213141516171819202122/** Get the lower 32 bit of the reference clock system time. * 获取参考时钟的低32位 * * This method can be used to synchronize the master to the reference clock. * 可以用于将主站时钟同步到参考时钟 * * The reference clock system time is queried via the * ecrt_master_sync_slave_clocks() method, that reads the system time of the * reference clock and writes it to the slave clocks (so be sure to call it * cyclically to get valid data). * * \\attention The returned time is the system time of the reference clock * minus the transmission delay of the reference clock. * * \\retval 0 success, system time was written into \\a time. * \\retval -ENXIO No reference clock found. * \\retval -EIO Slave synchronization datagram was not received. */int ecrt_master_reference_clock_time( ec_master_t *master, /**&lt; EtherCAT master. */ uint32_t *time /**&lt; Pointer to store the queried system time. */ ); ecrt_master_sync_slave_clocks 123456789/** Queues the DC clock drift compensation datagram for sending. * 将DC漂移补偿数据报排队发送 * * All slave clocks synchronized to the reference clock. * 使所有从站时钟同步到参考时钟 */void ecrt_master_sync_slave_clocks( ec_master_t *master /**&lt; EtherCAT master. */ ); ecrt_master_sync_reference_clock_to 1234567891011/** Queues the DC reference clock drift compensation datagram for sending. * 将DC参考时钟漂移补偿数据报排队发送。 * * The reference clock will by synchronized to the time passed in the * sync_time parameter. * 参考时钟会被同步到第二个参数的值 */void ecrt_master_sync_reference_clock_to( ec_master_t *master, /**&lt; EtherCAT master. */ uint64_t sync_time /**&lt; Sync reference clock to this time. */ ); ecrt_master_sync_reference_clock 123456789/** Queues the DC reference clock drift compensation datagram for sending. * * The reference clock will by synchronized to the application time provided * by the last call off ecrt_master_application_time(). * 与上一个函数功能类似，区别是不需要指定时间值，自动选择ecrt_master_application_time()获取的值。 */void ecrt_master_sync_reference_clock( ec_master_t *master /**&lt; EtherCAT master. */ ); 程序示例 从站：两个LAN9252 EtherCAT开发板 功能：流水灯 同步精度：从站作为参考时钟，同步精度达到20ns左右，收敛时间约为3分钟 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434#include &lt;errno.h&gt;#include &lt;signal.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/resource.h&gt;#include &lt;sys/time.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;time.h&gt;#include &lt;sys/mman.h&gt;#include &lt;malloc.h&gt;#include &quot;ecrt.h&quot;/*****************************************************************************/// ethercatstatic ec_master_t *master = NULL;static ec_domain_t *domain1 = NULL;static ec_slave_config_t *slave0 = NULL;static ec_slave_config_t *slave1 = NULL;/*****************************************************************************/// application parameters//#define CLOCK_TO_USE CLOCK_MONOTONIC #define CLOCK_TO_USE CLOCK_REALTIME#define cycle_t 10000000 /*本次设置周期PERIOD_NS为10ms*/#define NSEC_PER_SEC (1000000000L) #define TIMESPEC2NS(T) ((uint64_t) (T).tv_sec * NSEC_PER_SEC + (T).tv_nsec)#define SLAVE_REF 1 // 选择从站作为参考时钟：1 选择主站作为参考时钟：0const struct timespec cycletime = &#123;0, cycle_t&#125;;struct timespec wakeupTime; // 唤醒时间struct timespec sync_time; // 用于将主站时间写入从站 int cycle_times = 0; // 循环次数int LED[8] = &#123;1,1,1,1,1,1,1,1&#125;;int led = 0;uint32_t diff_time_ns; // 最大时钟偏移值，单位nsstruct timeval start,end; // 用于记录程序运行时间 FILE *fp = NULL; // 输出数据到csv文件/*****************************************************************************/// process data#define PANASONIC_0 0,0 /*EtherCAT address on the bus*/#define PANASONIC_1 0,1 /*EtherCAT address on the bus*/#define VID_PID 0x00000009, 0x00009252 /*Vendor ID, product code*/uint8_t *domain1_pd = NULL;unsigned int slave0_6000_01;unsigned int slave0_6000_01_bit;unsigned int slave0_6000_02;unsigned int slave0_6000_02_bit;unsigned int slave0_6000_03;unsigned int slave0_6000_03_bit;unsigned int slave0_6000_04;unsigned int slave0_6000_04_bit;unsigned int slave0_6000_05;unsigned int slave0_6000_05_bit;unsigned int slave0_6000_06;unsigned int slave0_6000_06_bit;unsigned int slave0_6000_07;unsigned int slave0_6000_07_bit;unsigned int slave0_6000_08;unsigned int slave0_6000_08_bit;unsigned int slave0_7010_01;unsigned int slave0_7010_01_bit;unsigned int slave0_7010_02;unsigned int slave0_7010_02_bit;unsigned int slave0_7010_03;unsigned int slave0_7010_03_bit;unsigned int slave0_7010_04;unsigned int slave0_7010_04_bit;unsigned int slave0_7010_05;unsigned int slave0_7010_05_bit;unsigned int slave0_7010_06;unsigned int slave0_7010_06_bit;unsigned int slave0_7010_07;unsigned int slave0_7010_07_bit;unsigned int slave0_7010_08;unsigned int slave0_7010_08_bit;unsigned int slave1_6000_01;unsigned int slave1_6000_01_bit;unsigned int slave1_6000_02;unsigned int slave1_6000_02_bit;unsigned int slave1_6000_03;unsigned int slave1_6000_03_bit;unsigned int slave1_6000_04;unsigned int slave1_6000_04_bit;unsigned int slave1_6000_05;unsigned int slave1_6000_05_bit;unsigned int slave1_6000_06;unsigned int slave1_6000_06_bit;unsigned int slave1_6000_07;unsigned int slave1_6000_07_bit;unsigned int slave1_6000_08;unsigned int slave1_6000_08_bit;unsigned int slave1_7010_01;unsigned int slave1_7010_01_bit;unsigned int slave1_7010_02;unsigned int slave1_7010_02_bit;unsigned int slave1_7010_03;unsigned int slave1_7010_03_bit;unsigned int slave1_7010_04;unsigned int slave1_7010_04_bit;unsigned int slave1_7010_05;unsigned int slave1_7010_05_bit;unsigned int slave1_7010_06;unsigned int slave1_7010_06_bit;unsigned int slave1_7010_07;unsigned int slave1_7010_07_bit;unsigned int slave1_7010_08;unsigned int slave1_7010_08_bit;const static ec_pdo_entry_reg_t domain1_regs[] = &#123; &#123;PANASONIC_0, VID_PID, 0x6000, 1, &amp;slave0_6000_01, &amp;slave0_6000_01_bit&#125;, &#123;PANASONIC_0, VID_PID, 0x6000, 2, &amp;slave0_6000_02, &amp;slave0_6000_02_bit&#125;, &#123;PANASONIC_0, VID_PID, 0x6000, 3, &amp;slave0_6000_03, &amp;slave0_6000_03_bit&#125;, &#123;PANASONIC_0, VID_PID, 0x6000, 4, &amp;slave0_6000_04, &amp;slave0_6000_04_bit&#125;, &#123;PANASONIC_0, VID_PID, 0x6000, 5, &amp;slave0_6000_05, &amp;slave0_6000_05_bit&#125;, &#123;PANASONIC_0, VID_PID, 0x6000, 6, &amp;slave0_6000_06, &amp;slave0_6000_06_bit&#125;, &#123;PANASONIC_0, VID_PID, 0x6000, 7, &amp;slave0_6000_07, &amp;slave0_6000_07_bit&#125;, &#123;PANASONIC_0, VID_PID, 0x6000, 8, &amp;slave0_6000_08, &amp;slave0_6000_08_bit&#125;, &#123;PANASONIC_0, VID_PID, 0x7010, 1, &amp;slave0_7010_01, &amp;slave0_7010_01_bit&#125;, &#123;PANASONIC_0, VID_PID, 0x7010, 2, &amp;slave0_7010_02, &amp;slave0_7010_02_bit&#125;, &#123;PANASONIC_0, VID_PID, 0x7010, 3, &amp;slave0_7010_03, &amp;slave0_7010_03_bit&#125;, &#123;PANASONIC_0, VID_PID, 0x7010, 4, &amp;slave0_7010_04, &amp;slave0_7010_04_bit&#125;, &#123;PANASONIC_0, VID_PID, 0x7010, 5, &amp;slave0_7010_05, &amp;slave0_7010_05_bit&#125;, &#123;PANASONIC_0, VID_PID, 0x7010, 6, &amp;slave0_7010_06, &amp;slave0_7010_06_bit&#125;, &#123;PANASONIC_0, VID_PID, 0x7010, 7, &amp;slave0_7010_07, &amp;slave0_7010_07_bit&#125;, &#123;PANASONIC_0, VID_PID, 0x7010, 8, &amp;slave0_7010_08, &amp;slave0_7010_08_bit&#125;, &#123;PANASONIC_1, VID_PID, 0x6000, 1, &amp;slave1_6000_01, &amp;slave1_6000_01_bit&#125;, &#123;PANASONIC_1, VID_PID, 0x6000, 2, &amp;slave1_6000_02, &amp;slave1_6000_02_bit&#125;, &#123;PANASONIC_1, VID_PID, 0x6000, 3, &amp;slave1_6000_03, &amp;slave1_6000_03_bit&#125;, &#123;PANASONIC_1, VID_PID, 0x6000, 4, &amp;slave1_6000_04, &amp;slave1_6000_04_bit&#125;, &#123;PANASONIC_1, VID_PID, 0x6000, 5, &amp;slave1_6000_05, &amp;slave1_6000_05_bit&#125;, &#123;PANASONIC_1, VID_PID, 0x6000, 6, &amp;slave1_6000_06, &amp;slave1_6000_06_bit&#125;, &#123;PANASONIC_1, VID_PID, 0x6000, 7, &amp;slave1_6000_07, &amp;slave1_6000_07_bit&#125;, &#123;PANASONIC_1, VID_PID, 0x6000, 8, &amp;slave1_6000_08, &amp;slave1_6000_08_bit&#125;, &#123;PANASONIC_1, VID_PID, 0x7010, 1, &amp;slave1_7010_01, &amp;slave1_7010_01_bit&#125;, &#123;PANASONIC_1, VID_PID, 0x7010, 2, &amp;slave1_7010_02, &amp;slave1_7010_02_bit&#125;, &#123;PANASONIC_1, VID_PID, 0x7010, 3, &amp;slave1_7010_03, &amp;slave1_7010_03_bit&#125;, &#123;PANASONIC_1, VID_PID, 0x7010, 4, &amp;slave1_7010_04, &amp;slave1_7010_04_bit&#125;, &#123;PANASONIC_1, VID_PID, 0x7010, 5, &amp;slave1_7010_05, &amp;slave1_7010_05_bit&#125;, &#123;PANASONIC_1, VID_PID, 0x7010, 6, &amp;slave1_7010_06, &amp;slave1_7010_06_bit&#125;, &#123;PANASONIC_1, VID_PID, 0x7010, 7, &amp;slave1_7010_07, &amp;slave1_7010_07_bit&#125;, &#123;PANASONIC_1, VID_PID, 0x7010, 8, &amp;slave1_7010_08, &amp;slave1_7010_08_bit&#125;, &#123;&#125;&#125;;/*****************************************************************************//* Slave 0, &quot;LAN9252-EVB-HBI&quot; * Vendor ID: 0x00000009 * Product code: 0x00009252 * Revision number: 0x00000001 */ec_pdo_entry_info_t slave_0_pdo_entries[] = &#123; &#123;0x7010, 0x01, 1&#125;, /* LED 1 */ &#123;0x7010, 0x02, 1&#125;, /* LED 2 */ &#123;0x7010, 0x03, 1&#125;, /* LED 3 */ &#123;0x7010, 0x04, 1&#125;, /* LED 4 */ &#123;0x7010, 0x05, 1&#125;, /* LED 5 */ &#123;0x7010, 0x06, 1&#125;, /* LED 6 */ &#123;0x7010, 0x07, 1&#125;, /* LED 7 */ &#123;0x7010, 0x08, 1&#125;, /* LED 8 */ &#123;0x0000, 0x00, 8&#125;, /* None */ &#123;0x6000, 0x01, 1&#125;, /* Switch 1 */ &#123;0x6000, 0x02, 1&#125;, /* Switch 2 */ &#123;0x6000, 0x03, 1&#125;, /* Switch 3 */ &#123;0x6000, 0x04, 1&#125;, /* Switch 4 */ &#123;0x6000, 0x05, 1&#125;, /* Switch 5 */ &#123;0x6000, 0x06, 1&#125;, /* Switch 6 */ &#123;0x6000, 0x07, 1&#125;, /* Switch 7 */ &#123;0x6000, 0x08, 1&#125;, /* Switch 8 */ &#123;0x0000, 0x00, 8&#125;, /* None */ &#123;0x6020, 0x01, 1&#125;, /* Underrange */ &#123;0x6020, 0x02, 1&#125;, /* Overrange */ &#123;0x6020, 0x03, 2&#125;, /* Limit 1 */ &#123;0x6020, 0x05, 2&#125;, /* Limit 2 */ &#123;0x0000, 0x00, 8&#125;, /* Gap */ &#123;0x1802, 0x07, 1&#125;, /* TxPDOState */ &#123;0x1802, 0x09, 1&#125;, /* TxPDO Toggle */ &#123;0x6020, 0x11, 16&#125;, /* Analog input */&#125;;ec_pdo_info_t slave_0_pdos[] = &#123; &#123;0x1601, 9, slave_0_pdo_entries + 0&#125;, /* DO Outputs */ &#123;0x1a00, 9, slave_0_pdo_entries + 9&#125;, /* DI Inputs */ &#123;0x1a02, 8, slave_0_pdo_entries + 18&#125;, /* AI TxPDO-Map */&#125;;ec_sync_info_t slave_0_syncs[] = &#123; &#123;0, EC_DIR_OUTPUT, 0, NULL, EC_WD_DISABLE&#125;, &#123;1, EC_DIR_INPUT, 0, NULL, EC_WD_DISABLE&#125;, &#123;2, EC_DIR_OUTPUT, 1, slave_0_pdos + 0, EC_WD_ENABLE&#125;, &#123;3, EC_DIR_INPUT, 2, slave_0_pdos + 1, EC_WD_DISABLE&#125;, &#123;0xff&#125;&#125;;/* Slave 1, &quot;LAN9252-EVB-HBI&quot; * Vendor ID: 0x00000009 * Product code: 0x00009252 * Revision number: 0x00000001 */ec_pdo_entry_info_t slave_1_pdo_entries[] = &#123; &#123;0x7010, 0x01, 1&#125;, /* LED 1 */ &#123;0x7010, 0x02, 1&#125;, /* LED 2 */ &#123;0x7010, 0x03, 1&#125;, /* LED 3 */ &#123;0x7010, 0x04, 1&#125;, /* LED 4 */ &#123;0x7010, 0x05, 1&#125;, /* LED 5 */ &#123;0x7010, 0x06, 1&#125;, /* LED 6 */ &#123;0x7010, 0x07, 1&#125;, /* LED 7 */ &#123;0x7010, 0x08, 1&#125;, /* LED 8 */ &#123;0x0000, 0x00, 8&#125;, /* None */ &#123;0x6000, 0x01, 1&#125;, /* Switch 1 */ &#123;0x6000, 0x02, 1&#125;, /* Switch 2 */ &#123;0x6000, 0x03, 1&#125;, /* Switch 3 */ &#123;0x6000, 0x04, 1&#125;, /* Switch 4 */ &#123;0x6000, 0x05, 1&#125;, /* Switch 5 */ &#123;0x6000, 0x06, 1&#125;, /* Switch 6 */ &#123;0x6000, 0x07, 1&#125;, /* Switch 7 */ &#123;0x6000, 0x08, 1&#125;, /* Switch 8 */ &#123;0x0000, 0x00, 8&#125;, /* None */ &#123;0x6020, 0x01, 1&#125;, /* Underrange */ &#123;0x6020, 0x02, 1&#125;, /* Overrange */ &#123;0x6020, 0x03, 2&#125;, /* Limit 1 */ &#123;0x6020, 0x05, 2&#125;, /* Limit 2 */ &#123;0x0000, 0x00, 8&#125;, /* Gap */ &#123;0x1802, 0x07, 1&#125;, /* TxPDOState */ &#123;0x1802, 0x09, 1&#125;, /* TxPDO Toggle */ &#123;0x6020, 0x11, 16&#125;, /* Analog input */&#125;;ec_pdo_info_t slave_1_pdos[] = &#123; &#123;0x1601, 9, slave_1_pdo_entries + 0&#125;, /* DO Outputs */ &#123;0x1a00, 9, slave_1_pdo_entries + 9&#125;, /* DI Inputs */ &#123;0x1a02, 8, slave_0_pdo_entries + 18&#125;, /* AI TxPDO-Map */&#125;;ec_sync_info_t slave_1_syncs[] = &#123; &#123;0, EC_DIR_OUTPUT, 0, NULL, EC_WD_DISABLE&#125;, &#123;1, EC_DIR_INPUT, 0, NULL, EC_WD_DISABLE&#125;, &#123;2, EC_DIR_OUTPUT, 1, slave_0_pdos + 0, EC_WD_ENABLE&#125;, &#123;3, EC_DIR_INPUT, 2, slave_0_pdos + 1, EC_WD_DISABLE&#125;, &#123;0xff&#125;&#125;;/*****************************************************************************/// Synchronise the distributed clocksvoid sync_distributed_clocks(void)&#123;#if SLAVE_REF uint32_t ref_time = 0; ecrt_master_reference_clock_time(master, &amp;ref_time);//获取参考时钟的低32位#else clock_gettime(CLOCK_TO_USE, &amp;sync_time); ecrt_master_sync_reference_clock_to(master, TIMESPEC2NS(sync_time));#endif ecrt_master_sync_slave_clocks(master);// call to sync slaves to ref slave&#125;/*****************************************************************************/// timespec相加struct timespec timespec_add(struct timespec time1, struct timespec time2)&#123; struct timespec result; if ((time1.tv_nsec + time2.tv_nsec) &gt;= NSEC_PER_SEC) &#123; result.tv_sec = time1.tv_sec + time2.tv_sec + 1; result.tv_nsec = time1.tv_nsec + time2.tv_nsec - NSEC_PER_SEC; &#125; else &#123; result.tv_sec = time1.tv_sec + time2.tv_sec; result.tv_nsec = time1.tv_nsec + time2.tv_nsec; &#125; return result;&#125;/*****************************************************************************/// Wait for the next periodvoid wait_period(void)&#123; clock_nanosleep(CLOCK_TO_USE, TIMER_ABSTIME, &amp;wakeupTime, NULL); ecrt_master_application_time(master, TIMESPEC2NS(wakeupTime)); wakeupTime = timespec_add(wakeupTime, cycletime);&#125;/*****************************************************************************/// 循环任务void cyclic_task()&#123; // wait for next period (using adjustable system time) wait_period(); // receive EtherCAT ecrt_master_receive(master); ecrt_domain_process(domain1); // 最大时钟偏移 diff_time_ns = ecrt_master_sync_monitor_process(master); // 返回所有从站时钟偏移中的最大值 fprintf(fp,&quot;%ld,&quot;,diff_time_ns); printf(&quot;最大时钟偏移 = %ld 纳秒\\n&quot;,diff_time_ns); // 程序运行时间 gettimeofday(&amp;end, NULL); uint32_t timeuse = 1000000*(end.tv_sec - start.tv_sec) + end.tv_usec-start.tv_usec; fprintf(fp,&quot;%ld\\n&quot;,timeuse); printf(&quot;程序运行时间 = %ld 微秒\\n&quot;,timeuse); // 流水灯逻辑 if(cycle_times &lt; 50)&#123; // 每500ms切换一次 cycle_times++; &#125;else&#123; cycle_times = 0; if(0&lt;led &amp;&amp; led&lt;7)&#123; LED[led-1] = 1; LED[led] = 0; led++; &#125;else if(led==7)&#123; LED[led-1] = 1; LED[led] = 0; led=0; &#125;else if(led==0)&#123; LED[7]=1; LED[0]=0; led=1; &#125; &#125; // write slave0 EC_WRITE_BIT(domain1_pd + slave0_7010_01, slave0_7010_01_bit, LED[0]); EC_WRITE_BIT(domain1_pd + slave0_7010_02, slave0_7010_02_bit, LED[1]); EC_WRITE_BIT(domain1_pd + slave0_7010_03, slave0_7010_03_bit, LED[2]); EC_WRITE_BIT(domain1_pd + slave0_7010_04, slave0_7010_04_bit, LED[3]); EC_WRITE_BIT(domain1_pd + slave0_7010_05, slave0_7010_05_bit, LED[4]); EC_WRITE_BIT(domain1_pd + slave0_7010_06, slave0_7010_06_bit, LED[5]); EC_WRITE_BIT(domain1_pd + slave0_7010_07, slave0_7010_07_bit, LED[6]); EC_WRITE_BIT(domain1_pd + slave0_7010_08, slave0_7010_08_bit, LED[7]); // write slave1 EC_WRITE_BIT(domain1_pd + slave1_7010_01, slave1_7010_01_bit, LED[0]); EC_WRITE_BIT(domain1_pd + slave1_7010_02, slave1_7010_02_bit, LED[1]); EC_WRITE_BIT(domain1_pd + slave1_7010_03, slave1_7010_03_bit, LED[2]); EC_WRITE_BIT(domain1_pd + slave1_7010_04, slave1_7010_04_bit, LED[3]); EC_WRITE_BIT(domain1_pd + slave1_7010_05, slave1_7010_05_bit, LED[4]); EC_WRITE_BIT(domain1_pd + slave1_7010_06, slave1_7010_06_bit, LED[5]); EC_WRITE_BIT(domain1_pd + slave1_7010_07, slave1_7010_07_bit, LED[6]); EC_WRITE_BIT(domain1_pd + slave1_7010_08, slave1_7010_08_bit, LED[7]); ecrt_domain_queue(domain1); sync_distributed_clocks(); // 读取所有从站0x092C寄存器(存储时钟偏移值) ecrt_master_sync_monitor_queue(master); ecrt_master_send(master);&#125;int main(int argc, char **argv)&#123; fp = fopen(&quot;/root/lan9252_test/diff_time_statistic.csv&quot;,&quot;w&quot;); master = ecrt_request_master(0); if (!master) return -1; domain1 = ecrt_master_create_domain(master); if (!domain1) return -1; // Create configuration for bus coupler slave0 = ecrt_master_slave_config(master, PANASONIC_0, VID_PID); if (!slave0) return -1; printf(&quot;Configuring PDOs...\\n&quot;); if (ecrt_slave_config_pdos(slave0, EC_END, slave_0_syncs)) &#123; fprintf(stderr, &quot;Failed to configure slave0 PDOs!\\n&quot;); exit(EXIT_FAILURE); &#125; else &#123; printf(&quot;*Success to configuring slave0 PDOs*\\n&quot;); &#125; slave1 = ecrt_master_slave_config(master, PANASONIC_1, VID_PID); if (!slave1) return -1; if (ecrt_slave_config_pdos(slave1, EC_END, slave_1_syncs)) &#123; fprintf(stderr, &quot;Failed to configure slave1 PDOs!\\n&quot;); exit(EXIT_FAILURE); &#125; else &#123; printf(&quot;*Success to configuring slave1 PDOs*\\n&quot;); &#125; if (ecrt_domain_reg_pdo_entry_list(domain1, domain1_regs)) &#123; fprintf(stderr, &quot;PDO entry registration failed!\\n&quot;); exit(EXIT_FAILURE); &#125; else&#123; printf(&quot;PDO entries sucess..\\n&quot;); &#125; // configure SYNC signals for this slave ecrt_slave_config_dc(slave0, 0x0300, cycle_t, 0, 0, 0); ecrt_slave_config_dc(slave1, 0x0300, cycle_t, 0, 0, 0); ecrt_master_select_reference_clock(master, slave0); printf(&quot;Activating master...\\n&quot;); if (ecrt_master_activate(master)) return -1; if (!(domain1_pd = ecrt_domain_data(domain1))) &#123; return -1; &#125; clock_gettime(CLOCK_TO_USE, &amp;wakeupTime); printf(&quot;Start running...\\n&quot;); gettimeofday(&amp;start, NULL); while(1)&#123; cyclic_task(); &#125;&#125;","categories":[{"name":"C","slug":"C","permalink":"http://zhongriqian.github.io/categories/C/"}],"tags":[{"name":"EtherCAT","slug":"EtherCAT","permalink":"http://zhongriqian.github.io/tags/EtherCAT/"},{"name":"C","slug":"C","permalink":"http://zhongriqian.github.io/tags/C/"},{"name":"Linux","slug":"Linux","permalink":"http://zhongriqian.github.io/tags/Linux/"}]},{"title":"多网卡主机Docker网络配置问题","slug":"多网卡主机Docker网络配置问题","date":"2023-02-19T16:00:00.000Z","updated":"2023-02-21T06:44:45.884Z","comments":true,"path":"2023/02/20/多网卡主机Docker网络配置问题/","link":"","permalink":"http://zhongriqian.github.io/2023/02/20/%E5%A4%9A%E7%BD%91%E5%8D%A1%E4%B8%BB%E6%9C%BADocker%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/","excerpt":"","text":"测试环境 使用树莓派作为多网卡主机，其具备两张网卡，eth0和wlan0。另外需要一台PC用于测试与树莓派上容器的通信。将两台设备接入同一WiFi，然后再将两设备用网线直连。这样两设备即可以通过WiFi通信，也可以通过网线通信。 WiFi网段为192.168.31.0/24，树莓派IP为192.168.31.154，PC的IP为192.168.31.69。 网线连接的局域网网段为169.254.0.0/16，树莓派IP为169.254.140.68，PC的IP为169.254.140.66。 在树莓派上部署容器（容器为PLC运行环境容器），并对容器做不同的docker网络配置，测试PC与容器的通信，包括PC上的PLC开发环境软件（IDE）是否能接入容器，以及从容器内部是否能ping通PC。 1234567891011121314151617# 树莓派网卡信息2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000 link/ether dc:a6:32:de:1f:25 brd ff:ff:ff:ff:ff:ff inet 169.254.140.68/16 brd 169.254.255.255 scope global noprefixroute eth0 valid_lft forever preferred_lft forever inet6 fe80::9b39:2105:8832:4cf6/64 scope link valid_lft forever preferred_lft forever3: wlan0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether dc:a6:32:de:1f:26 brd ff:ff:ff:ff:ff:ff inet 192.168.31.154/24 brd 192.168.31.255 scope global dynamic noprefixroute wlan0 valid_lft 36699sec preferred_lft 31299sec inet6 fd00:6868:6868::b91/128 scope global dynamic noprefixroute valid_lft 36696sec preferred_lft 36696sec inet6 fd00:6868:6868:0:77e8:ee3:7b24:7a36/64 scope global mngtmpaddr noprefixroute valid_lft forever preferred_lft forever inet6 fe80::215f:7f6a:a210:4d05/64 scope link valid_lft forever preferred_lft forever 1234567891011121314151617# PC网卡信息以太网适配器 以太网 2: 连接特定的 DNS 后缀 . . . . . . . : 本地链接 IPv6 地址. . . . . . . . : fe80::62de:7603:51d9:79cc%17 IPv4 地址 . . . . . . . . . . . . : 169.254.140.66 子网掩码 . . . . . . . . . . . . : 255.255.0.0 默认网关. . . . . . . . . . . . . :无线局域网适配器 WLAN: 连接特定的 DNS 后缀 . . . . . . . : IPv6 地址 . . . . . . . . . . . . : fd00:6868:6868::69 IPv6 地址 . . . . . . . . . . . . : fd00:6868:6868:0:dbe:a764:e44b:ccec 临时 IPv6 地址. . . . . . . . . . : fd00:6868:6868:0:314c:b64b:89c7:1ef7 本地链接 IPv6 地址. . . . . . . . : fe80::b5c6:65b9:81b9:948f%16 IPv4 地址 . . . . . . . . . . . . : 192.168.31.69 子网掩码 . . . . . . . . . . . . : 255.255.255.0 默认网关. . . . . . . . . . . . . : fe80::cabf:4cff:fe4b:76d7%16 192.168.31.1 入向网络配置 入向：网络内其他设备访问主机上部署的容器 host模式 使用host网络模式创建容器，容器直接使用主机的网络配置。 1docker run -it --net=host 0375866a09cd 所以PC上的IDE以树莓派的两个IP（169.254.140.68、192.168.31.154）作为目的地址都可以接入RTE。 bridge模式（不绑定网卡） 使用bridge网络模式创建容器，会将容器接入docker0虚拟网桥下，网桥网段一般为172.17.0.0/16。这种模式下，主机所在网段内的其他设备无法直接访问主机上的容器，需要在容器与主机间做端口映射。 1docker run -it --net=bridge -p 3000:3000 0375866a09cd 因为没有绑定网卡，只设置了端口映射，所以IDE以树莓派两个IP（169.254.140.68、192.168.31.154）作为目的地址都可以接入RTE。 bridge模式（绑定网卡） bridge模式创建容器，可以在设置端口映射时指定网卡IP，这样网络内其他设备只能从指定的主机网卡IP访问到容器。 1docker run -it --net=bridge -p 192.168.31.154:3000:3000 0375866a09cd 使用上面命令创建容器后，PC上的IDE只有把树莓派IP 192.168.31.154作为目的地址，才能访问到RTE容器。 相应的，如果创建容器时设置容器绑定到169.254.140.68，那IDE只有把树莓派IP 169.254.140.68作为目的地址，才能访问到RTE容器。 出向网络配置 出向：主机上部署的容器访问网络内其他设备 host模式 在容器内ping主机所在的两个网段内的其他设备（如PC的两个网卡IP：192.168.31.69、169.254.140.66）都可以ping通。 bridge模式 使用bridege模式创建容器，可以使用自带的docker0网桥，但缺点是创建容器时不能指定IP。使用自己创建的docker网桥，可以解决这个问题。另外对于docker0以及所有新建的docker网桥，系统会自动添加一条路由规则，使网桥网段内的所有容器都可以访问到主机所在的所有网段。使用命令“iptables -t nat -nvL --line-numbers”查看路由规则。如下面POSTROUTING链中的第一条规则，docker0网段（172.17.0.0/16）下的容器可以访问主机所在的所有网段。 123Chain POSTROUTING (policy ACCEPT 0 packets, 0 bytes)num pkts bytes target prot opt in out source destination 1 0 0 MASQUERADE all -- * !docker0 172.17.0.0/16 0.0.0.0/0 新创建一个名为docker1的docker网络后，重新查看发现多出一条规则。 12# 创建网络（此处新建的网络本质也是bridge模式）docker network create --dirver bridge --subnet 172.18.0.0/16 --opt &quot;com.docker.network.bridge.name&quot;=&quot;docker1&quot; docker1 1234Chain POSTROUTING (policy ACCEPT 0 packets, 0 bytes)num pkts bytes target prot opt in out source destination 1 0 0 MASQUERADE all -- * !docker1 172.18.0.0/16 0.0.0.0/0 2 17 1234 MASQUERADE all -- * !docker0 172.17.0.0/16 0.0.0.0/0 然后创建容器，网络使用自己创建的docker1，但就像前面提到的，每个docker网络自动添加的路由规则，会使docker网络下的容器能访问到主机所在的所有网段。创建两个容器（rte1、rte2）测试一下。 123#创建容器，加入docker1docker run -d --net docker1 -p 3001:3000 --name rte1 0375866a09cddocker run -d --net docker1 -p 3001:3000 --name rte2 0375866a09cd 创建容器后，查看规则，没有针对容器IP的出向规则，只有针对整个网段的。 123456Chain POSTROUTING (policy ACCEPT 0 packets, 0 bytes)num pkts bytes target prot opt in out source destination 1 0 0 MASQUERADE all -- * !docker1 172.18.0.0/16 0.0.0.0/0 2 17 1234 MASQUERADE all -- * !docker0 172.17.0.0/16 0.0.0.0/0 3 0 0 MASQUERADE tcp -- * * 172.18.0.2 172.18.0.2 tcp dpt:30004 0 0 MASQUERADE tcp -- * * 172.18.0.3 172.18.0.3 tcp dpt:3000 从两个容器内向192.168.31.0/24和169.254.0.0/16两个网段ping，发现都能ping通。 如果想让某个容器只能访问192.168.31.0/24网段，另一个容器只能访问169.254.0.0/16网段，可以手动添加路由规则。 再创建两个容器（rte3、rte4），在创建时指定两个容器的IP。 123#创建容器，加入docker1，指定IPdocker run -d --net docker1 --ip 172.18.0.33 -p 3002:3000 --name rte3 0375866a09cddocker run -d --net docker1 --ip 172.18.0.44 -p 3004:3000 --name rte4 0375866a09cd 此时新建的两个容器（rte3、4）都在原本路由规则覆盖下，所以先删除docker1网络自动添加的路由规则。以规则序号为目标删除。 12# 删除POSTROUTING链下的序号1的规则iptables -t nat -D POSTROUTING 1 重新查看路由规则，docker1的出向路由规则已被删除。在rte3、4内向两个网段ping，都ping不通。 1234567Chain POSTROUTING (policy ACCEPT 0 packets, 0 bytes)num pkts bytes target prot opt in out source destination 1 17 1234 MASQUERADE all -- * !docker0 172.17.0.0/16 0.0.0.0/0 2 0 0 MASQUERADE tcp -- * * 172.18.0.2 172.18.0.2 tcp dpt:30003 0 0 MASQUERADE tcp -- * * 172.18.0.3 172.18.0.3 tcp dpt:30004 0 0 MASQUERADE tcp -- * * 172.18.0.33 172.18.0.33 tcp dpt:30005 0 0 MASQUERADE tcp -- * * 172.18.0.44 172.18.0.44 tcp dpt:3000 然后手动添加规则，完成目标需求。 12345# 配置nat，容器rte3向外发送的数据包源IP转换成192.168.31.154iptables -t nat -I POSTROUTING -p all -s 172.18.0.33 -j SNAT --to-source 192.168.31.154# 配置nat，容器rte4向外发送的数据包源IP转换成169.254.140.66iptables -t nat -I POSTROUTING -p all -s 172.18.0.44 -j SNAT --to-source 169.254.140.68 123456789Chain POSTROUTING (policy ACCEPT 0 packets, 0 bytes)num pkts bytes target prot opt in out source destination 1 0 0 SNAT all -- * * 172.18.0.44 0.0.0.0/0 to:169.254.140.682 0 0 SNAT all -- * * 172.18.0.33 0.0.0.0/0 to:192.168.31.1543 17 1234 MASQUERADE all -- * !docker0 172.17.0.0/16 0.0.0.0/0 4 0 0 MASQUERADE tcp -- * * 172.18.0.2 172.18.0.2 tcp dpt:30005 0 0 MASQUERADE tcp -- * * 172.18.0.3 172.18.0.3 tcp dpt:30006 0 0 MASQUERADE tcp -- * * 172.18.0.33 172.18.0.33 tcp dpt:30007 0 0 MASQUERADE tcp -- * * 172.18.0.44 172.18.0.44 tcp dpt:3000 配置完成后，再次测试，发现在容器rte3中，ping 192.168.31.69能通，ping 169.254.140.66不通；在容器rte4中，ping 169.254.140.66能通，ping 192.168.31.69不通，和目标需求一致。 当然除了可以添加针对IP的规则，也可以添加针对网段的规则，比如：创建了两个docker网络（docker11、docker22），希望docker11下的容器只能访问网段192.168.31.0/24，docker22下的容器只能访问网段169.254.0.0/16。可以如下配置。 1234567# 创建docker网络docker network create --dirver bridge --subnet 172.19.0.0/16 --opt &quot;com.docker.network.bridge.name&quot;=&quot;docker11&quot; docker11docker network create --dirver bridge --subnet 172.20.0.0/16 --opt &quot;com.docker.network.bridge.name&quot;=&quot;docker22&quot; docker22# 配置natiptables -t nat -I POSTROUTING -p all -s 172.19.0.0/16 -j SNAT --to-source 192.168.31.154iptables -t nat -I POSTROUTING -p all -s 172.20.0.0/16 -j SNAT --to-source 169.254.140.68 总结 入向（网络内其他设备到主机上的容器）：创建容器时通过参数（-p）绑定某一网卡后，网络内其他设备只能通过容器绑定的网卡IP访问容器 出向（主机上的容器到网络内其他设备）：配置nat，将容器IP转换为网卡IP，从而使容器能够访问网卡IP所在网段内的其他设备","categories":[{"name":"Docker","slug":"Docker","permalink":"http://zhongriqian.github.io/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://zhongriqian.github.io/tags/Docker/"}]},{"title":"Socket网络编程","slug":"Socket网络编程","date":"2023-02-07T16:00:00.000Z","updated":"2023-02-08T06:23:00.065Z","comments":true,"path":"2023/02/08/Socket网络编程/","link":"","permalink":"http://zhongriqian.github.io/2023/02/08/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","excerpt":"","text":"结构体 各类结构体以不同方式存放不同类型、不同数量的Socket信息，作为不同Socket接口函数的输入参数使用 in_addr 表示32位的IPv4地址 123456789#include &lt;arpa/inet.h&gt;// 用于表示32位的IPv4地址struct in_addr&#123; in_addr_t s_addr;&#125;// int_addr_t类型为unsigned int，长度为4字节（32位），字节序为网络顺序（大端字节序）// 如IP地址192.168.3.144，用int_addr_t类型存储为0Xc0a80390 sockaddr 套接字结构 123456789#include &lt;sys/socket.h&gt;struct sockaddr&#123; sa_family_t sin_family; // 协议族 char sa_data[14]; // 套接字中的目标IP和端口&#125;// sa_family_t类型为unsigned short，长度为2字节（16位）// 取值包括：AF_INET、AF_INET6、AF_UNSPE sockaddr_in 套接字结构 12345678910#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;struct sockaddr_in&#123; sa_family_t sin_family; // 协议族 unsigned short sin_port; // 端口号 struct in_addr sin_addr; // IP地址结构体 char sin_zero[8]; // 填充，为了与sockaddr结构体在内存中对齐，方便相互转换&#125; 函数 字节序转换 字节序指在内存中存放大于一个字节的数据时，数据各字节的存放顺序。 字节序可分为： 大端字节序：高位字节在前，低位字节在后 小端字节序：低位字节在前，高位字节在后 设计两种字节序的原因： 大端字节序符合人类的读写习惯，比如我们想存放“一千二百三十四”这个十进制数字（转换为十六进制为0x04D2），用大端字节序存储后，当我们读取时还是0x04D2。 但如果用小端字节序存储，读取时就变为0xD204。虽然小端字节序不符合人类读写习惯，但有利于提高计算效率，因为计算机计算时都是从数据的低位开始计算。 主机字节序：小端字节序 网络字节序：大端字节序 普通数据的字节序转换 主机字节序—&gt;网络字节序 功能：无符号32位/16位整型数据转换 参数：主机字节序数据 返回值：网络字节序数据 1234#include &lt;arpa/inet.h&gt;uint32_t htonl(uint32_t hostlong);uint16_t htons(uint16_t hostshort); 网络字节序—&gt;主机字节序 功能：无符号32位/16位整型数据转换 参数：网络字节序数据 返回值：主机字节序数据 1234#include &lt;arpa/inet.h&gt;uint32_t ntohl(uint32_t netlong);uint16_t ntohs(uint16_t netshort); IP地址的字节序转换 字符串—&gt;网络字节序 inet_pton 参数af：地址协议族（AF_INET、AF_INET6） 参数strptr：指向IP字符串存储地址的指针 参数addrptr：指向网络字节序IP数据存储地址的指针 返回值：成功返回1，输入的IP地址无效返回0，出错返回-1 123#include &lt;arpa/inet.h&gt;int inet_pton(int af, const char *strptr, void *addrptr); inet_aton 参数cp：指向IP字符串存储地址的指针 参数inp：指向in_addr结构体的指针，结构体内s_addr存储转换后的格式为网络字节序的32位二进制格式的IP 返回值：成功返回非0，IP地址无效返回0 123#include &lt;arpa/inet.h&gt;int inet_aton(const char *cp, struct in_addr *inp); inet_addr 参数cp：指向IP字符串存储地址的指针 返回值：in_addr_t类型变量，存储网络字节序的32位二进制格式的IP 123#include &lt;arpa/inet.h&gt;in_addr_t inet_addr(const char *cp); 字符串—&gt;主机字节序 inet_network 参数cp：指向IP字符串存储地址的指针 返回值：in_addr_t类型变量，存储主机字节序的32位二进制格式的IP 123#include &lt;arpa/inet.h&gt;in_addr_t inet_network(const char *cp); 网络字节序—&gt;字符串 inet_ntop 参数af：地址协议族 参数addrptr：指向网络字节序IP数据存储地址的指针 参数strptr：指向IP字符串存储地址的指针 参数len：IP字符串存储地址空间大小 返回值：成功返回参数strptr的指针，失败返回NULL且修改errno的值。 123#include &lt;arpa/inet.h&gt;const char *inet_ntop(int af, const void *addrptr, char *strptr, size_t len); inet_ntoa 参数in：in_addr结构体，结构体内s_addr存储网络字节序的32位二进制格式的IP 返回值：指向IP字符串存储地址的指针 123#include &lt;arpa/inet.h&gt;char *inet_ntoa(struct in_addr in); 测试 测试inet_pton、inet_ntop 1234567891011121314151617181920212223#include &lt;stdio.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;string.h&gt;int main()&#123; // 测试inet_pton char ip_str[] =&quot;193.168.1.10&quot;; in_addr_t ip_addr; int re = inet_pton(AF_INET, ip_str, (void *)&amp;ip_addr); printf(&quot;inet_pton返回值 = %d\\n&quot;,re); // inet_pton返回值 = 1 printf(&quot;ip_addr = %d\\n&quot;,ip_addr); // ip_addr = 167880897 printf(&quot;-------\\n&quot;); // 测试inet_ntop char ip_str2[INET_ADDRSTRLEN]; const char *re2 = inet_ntop(AF_INET, (const void *)&amp;ip_addr, ip_str2, sizeof(ip_str2)); printf(&quot;inet_ntop返回值 = %s\\n&quot;, re2); // inet_ntop返回值 = 193.168.1.10 printf(&quot;ip_str2 = %s\\n&quot;,ip_str2); // ip_str2 = 193.168.1.10&#125; 测试inet_aton、inet_ntoa 123456789101112131415161718192021#include &lt;stdio.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;string.h&gt;int main()&#123; // 测试inet_aton char ip_str[] =&quot;193.168.1.10&quot;; struct in_addr ip_addr; int re = inet_aton(ip_str, &amp;ip_addr); printf(&quot;inet_aton返回值 = %d\\n&quot;,re); // inet_aton返回值 = 1 printf(&quot;ip_addr.s_addr = %d\\n&quot;,ip_addr.s_addr); // ip_addr.s_addr = 167880897 printf(&quot;-------\\n&quot;); // 测试inet_ntoa char *ip_str2; ip_str2 = inet_ntoa(ip_addr); printf(&quot;inet_ntoa返回值 = %s\\n&quot;, ip_str2); // inet_ntoa返回值 = 193.168.1.10&#125; 测试inet_addr、inet_network 12345678910111213141516171819#include &lt;stdio.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;string.h&gt;int main()&#123; // 测试inet_addr char ip_str[] =&quot;193.168.1.10&quot;; struct in_addr ip_addr1; ip_addr1.s_addr = inet_addr(ip_str); printf(&quot;inet_addr返回值 = %u\\n&quot;,ip_addr1.s_addr); // inet_addr返回值 = 167880897 printf(&quot;-------\\n&quot;); // 测试inet_network struct in_addr ip_addr2; ip_addr2.s_addr = inet_network(ip_str); printf(&quot;inet_network返回值 = %u\\n&quot;, ip_addr2.s_addr); // inet_network返回值 = 3249013002&#125; IP地址处理 IP地址—&gt;主机地址 参数in：in_addr结构体 返回值：in_addr_t类型变量，存储主机字节序的主机地址数据 12345#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;in_addr_t inet_lnaof(struct in_addr in); IP地址—&gt;网络地址 参数in：in_addr结构体 返回值：in_addr_t类型变量，存储主机字节序的网络地址数据 12345#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;in_addr_t inet_netof(struct in_addr in); 主机地址+网络地址—&gt;IP地址 参数net：in_addr_t类型变量，存储网络字节序的网络地址数据 参数host：in_addr_t类型变量，存储网络字节序的主机地址数据 返回值：in_addr结构体，内部包含in_addr_t类型变量，存储网络主机字节序的IP地址数据 12345#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;struct in_addr inet_makeaddr(in_addr_t net, in_addr_t host); 测试 测试inet_lnaof、inet_netof、inet_makeaddr 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;stdio.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;string.h&gt;int main()&#123; char ip_str1[] = &quot;44.135.86.12&quot;; char ip_str2[] = &quot;172.16.23.95&quot;; char *ip_str; char *net_str1; char *net_str2; char *host_str1; char *host_str2; struct in_addr ip_addr1; struct in_addr ip_addr2; struct in_addr ip_addr; struct in_addr net_addr1; struct in_addr net_addr2; struct in_addr host_addr1; struct in_addr host_addr2; inet_aton(ip_str1,&amp;ip_addr1); // 将IP地址从字符串格式转为网络字节序的32位二进制格式 host_addr1.s_addr = inet_lnaof(ip_addr1); // 将IP地址转换为主机地址，格式为主机字节序的32位二进制格式 host_addr1.s_addr = htonl(host_addr1.s_addr); // 主机字节序转换为网络字节序 host_str1 = inet_ntoa(host_addr1); // 将主机地址从网络字节序的32位二进制格式转换为字符串格式 printf(&quot;主机地址：%s\\n&quot;,host_str1); net_addr1.s_addr = inet_netof(ip_addr1); // 将IP地址转换为网络地址，格式为主机字节序的32位二进制格式 net_addr1.s_addr = htonl(net_addr1.s_addr); // 主机字节序转换为网络字节序 net_str1 = inet_ntoa(net_addr1); // 将主机地址从网络字节序的32位二进制格式转换为字符串格式 printf(&quot;网络地址：%s\\n&quot;,net_str1); host_addr1.s_addr = ntohl(host_addr1.s_addr); // 网络字节序转换为主机字节序 net_addr1.s_addr = ntohl(net_addr1.s_addr); // 网络字节序转换为主机字节序 ip_addr = inet_makeaddr(net_addr1.s_addr, host_addr1.s_addr); // 网络地址和主机地址合成IP地址，格式为网络字节序的32位二进制格式 ip_str = inet_ntoa(ip_addr); // 将IP地址从网络字节序的32位二进制格式转换为字符串格式 printf(&quot;IP地址：%s\\n&quot;,ip_str); inet_aton(ip_str2,&amp;ip_addr2); host_addr2.s_addr = inet_lnaof(ip_addr2); host_addr2.s_addr = htonl(host_addr2.s_addr); host_str2 = inet_ntoa(host_addr2); printf(&quot;主机地址：%s\\n&quot;,host_str2); net_addr2.s_addr = inet_netof(ip_addr2); net_addr2.s_addr = htonl(net_addr2.s_addr); net_str2 = inet_ntoa(net_addr2); printf(&quot;网络地址：%s\\n&quot;,net_str2);&#125; 常规SocketC TCP 服务端 客户端 UDP 服务端 客户端","categories":[{"name":"Linux","slug":"Linux","permalink":"http://zhongriqian.github.io/categories/Linux/"}],"tags":[{"name":"C","slug":"C","permalink":"http://zhongriqian.github.io/tags/C/"},{"name":"Linux","slug":"Linux","permalink":"http://zhongriqian.github.io/tags/Linux/"},{"name":"Socket","slug":"Socket","permalink":"http://zhongriqian.github.io/tags/Socket/"}]},{"title":"Linux常用网络命令","slug":"Linux常用网络命令","date":"2023-01-27T16:00:00.000Z","updated":"2023-02-16T07:24:14.176Z","comments":true,"path":"2023/01/28/Linux常用网络命令/","link":"","permalink":"http://zhongriqian.github.io/2023/01/28/Linux%E5%B8%B8%E7%94%A8%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4/","excerpt":"","text":"ifconfig 功能 显示网络设备信息 常用参数示例 123456# 显示某网卡信息ifconfig eth0# 配置网卡IPifconfig ehx x.x.x.x netmask x.x.x.xifconfig eh0 192.168.10.2 netmask 255.255.255.0 ip 功能 显示网络设备信息 常用参数示例 123456789# 显示网卡设备信息ip a# 显示网卡设备链路层信息ip linkip -s link# 查看所在局域网内设备MAC地址ip neighbor ping 功能 发送ICMP包，检测网络状态 常用参数示例 1234567891011121314# 检测到IP为192.168.137.16主机的网络ping 192.168.137.16# 指定发送次数ping -c 10 192.168.137.16# 指定发送时间间隔（单位s，缺省值1s）ping -i 10 192.168.137.16# 指定持续发送时间（单位s）ping -w 10 192.168.137.16# 指定发送数据包字节数（缺省64字节，其中ICMP包头8字节、负载56字节，最大65535字节）ping -s 1000 192.168.137.16 route 功能 显示和操作路由表 常用参数示例 1234567891011121314151617# 显示路由表route -nee# 添加主机路由route add -host 192.168.1.2 gw 172.16.0.1 dev eth0# 添加网络路由route add -net 192.168.0.0 netmask 255.255.255.0 gw 172.16.0.1 dev eth0route add -net 192.168.0.0/24 gw 172.16.0.1 dev eth0# 添加默认路由route add -net 0.0.0.0 netmask 0.0.0.0 gw 172.16.0.1route add -net 0.0.0.0/0 gw 172.16.0.1route add default gw 172.16.0.1# 删除路由route add -host 192.168.1.2 gw 172.16.0.1 dev eth0 netstat 功能 查看网络状态、路由表、接口信息等 常用参数示例 1234567891011# 显示所有TCP协议相关信息，及其所属进程netstat -anpt# 显示所有UDP协议相关信息，及其所属进程netstat -anpu# 显示路由表netstat -r# 显示网卡信息netstat -i ss 功能 获取socket信息 常用参数示例 12345# 显示所有TCP协议相关信息，及其所属进程ss -apt# 显示所有UDP协议相关信息，及其所属进程ss -apu traceroute 功能 测试当前主机到目标主机间经过的网络节点 常用参数示例 12345# 检测当前主机到IP地址为192.168.1.1的主机间经过的网络节点traceroute 192.168.1.1# 检测当前主机到域名为www.baidu.com的主机间经过的网络节点traceroute www.baidu.com nslookup 功能 域名解析 dig 功能 域名解析 arp 功能 操作arp缓冲区 常用参数示例 1234# 显示arp表（IP与MAC对于关系）arp -n# 显示arp表（主机名与MAC对应关系）arp -e nmap 功能 端口扫描、网络扫描 常用参数示例 1234567891011# 查看本机开放的TCP端口nmap -sT 127.0.0.1# 查看本机开放的UDP端口nmap -sU 127.0.0.1# 扫描192.168.1.0/24网段中开放80端口的主机nmap -p 80 192.168.1.0/24# 扫描192.168.1.0/24网段中有哪些存活的主机nmap -n -sP 192.168.1.0/24","categories":[{"name":"Linux","slug":"Linux","permalink":"http://zhongriqian.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://zhongriqian.github.io/tags/Linux/"}]},{"title":"数采网关程序——Modbus-RTU与MQTT协议转换","slug":"数采网关程序——Modbus-RTU与MQTT协议转换","date":"2022-08-16T16:00:00.000Z","updated":"2023-01-28T08:53:58.637Z","comments":true,"path":"2022/08/17/数采网关程序——Modbus-RTU与MQTT协议转换/","link":"","permalink":"http://zhongriqian.github.io/2022/08/17/%E6%95%B0%E9%87%87%E7%BD%91%E5%85%B3%E7%A8%8B%E5%BA%8F%E2%80%94%E2%80%94Modbus-RTU%E4%B8%8EMQTT%E5%8D%8F%E8%AE%AE%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#include &lt;modbus.h&gt;#include &lt;unistd.h&gt;#include &lt;MQTTClient.h&gt;#define ADDRESS &quot;&quot;#define CLIENTID &quot;&quot;#define LOOP 10#define SERVER_ID 1#define ADDRESS_START 0#define ADDRESS_END 4#define CODE 1void publish(MQTTClient client, char* topic, char* payload) &#123; MQTTClient_message pubmsg = MQTTClient_message_initializer; pubmsg.payload = payload; pubmsg.payloadlen = strlen(pubmsg.payload); pubmsg.qos = 2; pubmsg.retained = 0; MQTTClient_deliveryToken token; MQTTClient_publishMessage(client, topic, &amp;pubmsg, &amp;token); MQTTClient_waitForCompletion(client, token, 1000L); printf(&quot;Message &#x27;%s&#x27; with delivery token %d delivered\\n&quot;, payload, token);&#125;int on_message(void *context, char *topicName, int topicLen, MQTTClient_message *message) &#123; char* payload = message-&gt;payload; printf(&quot;Received operation %s\\n&quot;, payload); MQTTClient_freeMessage(&amp;message); MQTTClient_free(topicName); return 1;&#125;int main(void)&#123; modbus_t *ctx; int rc; int nb_fail; int nb_loop; int addr; int nb; uint8_t *tab_rp_bits; uint16_t *tab_rp_registers; char buffer[100]; /*MQTT initialize*/ MQTTClient client; MQTTClient_create(&amp;client, ADDRESS, CLIENTID, MQTTCLIENT_PERSISTENCE_NONE, NULL); MQTTClient_connectOptions conn_opts = MQTTClient_connectOptions_initializer; conn_opts.username = &quot;&quot;; conn_opts.password = &quot;&quot;; MQTTClient_setCallbacks(client, NULL, NULL, on_message, NULL); int rc_mqtt; if ((rc_mqtt = MQTTClient_connect(client, &amp;conn_opts)) != MQTTCLIENT_SUCCESS) &#123; printf(&quot;Failed to connect, return code %d\\n&quot;, rc_mqtt); exit(-1); &#125; //create device publish(client, &quot;s/us&quot;, &quot;100,USTB_TEST,c8y_MQTTDevice&quot;); //set hardware information publish(client, &quot;s/us&quot;, &quot;110,S123456789,MQTT test model,Rev0.1&quot;); //listen for operation MQTTClient_subscribe(client, &quot;s/ds&quot;, 0); /* RTU */ ctx = modbus_new_rtu(&quot;/dev/ttyS1&quot;, 19200, &#x27;N&#x27;, 8, 1); modbus_set_slave(ctx, SERVER_ID); /* TCP */// ctx = modbus_new_tcp(&quot;127.0.0.1&quot;, 1502);// ctx = modbus_new_tcp(&quot;192.168.72.61&quot;, 502);// modbus_set_debug(ctx, TRUE); if (modbus_connect(ctx) == -1) &#123; fprintf(stderr, &quot;Connection failed: %s\\n&quot;, modbus_strerror(errno)); modbus_free(ctx); return -1; &#125; nb = ADDRESS_END - ADDRESS_START; if(CODE == 1 || CODE == 2)&#123; tab_rp_bits = (uint8_t *) malloc(nb * sizeof(uint8_t)); memset(tab_rp_bits, 0, nb * sizeof(uint8_t)); &#125; else&#123; tab_rp_registers = (uint16_t *) malloc(nb * sizeof(uint16_t)); memset(tab_rp_registers, 0, nb * sizeof(uint16_t)); &#125; nb_loop = nb_fail = 0; while (nb_loop++ &lt; LOOP) &#123; int i; addr = ADDRESS_START; switch(CODE)&#123; case 1: rc = modbus_read_bits(ctx, addr, nb, tab_rp_bits);break; // modbus功能码01 case 2: rc = modbus_read_input_bits(ctx, addr, nb, tab_rp_bits);break; // modbus功能码02 case 3: rc = modbus_read_registers(ctx, addr, nb, tab_rp_registers);break; // modbus功能码03 case 4: rc = modbus_read_input_registers(ctx, addr, nb, tab_rp_registers);break; // modbus功能码04 default: rc = 0; &#125; printf(&quot;&lt;&lt;\\n&quot;); if (rc != nb) &#123; printf(&quot;ERROR modbus_read_registers (%d)\\n&quot;, rc); printf(&quot;Address = %d, nb = %d\\n&quot;, addr, nb); nb_fail++; &#125; else &#123; for (i=0; i&lt;nb; i++) &#123; buffer[0] = &#x27;\\0&#x27;; switch(CODE)&#123; case 1: printf(&quot;Address = %d, Status = %X\\n&quot;, addr+i, tab_rp_bits[i]); sprintf(buffer,&quot;%s%s%d%s%d&quot;,&quot;200,&quot;, &quot;Register_Address_&quot;,ADDRESS_START+i, &quot;,ustb_test,&quot;, tab_rp_bits[i]); break; case 2:printf(&quot;Address = %d, Status = %X\\n&quot;, addr+i, tab_rp_bits[i]); sprintf(buffer,&quot;%s%s%d%s%d&quot;,&quot;200,&quot;, &quot;Register_Address_&quot;,ADDRESS_START+i, &quot;,ustb_test,&quot;, tab_rp_bits[i]); break; case 3:printf(&quot;Address = %d, Value = %d\\n&quot;, ADDRESS_START+i, tab_rp_registers[i]); sprintf(buffer,&quot;%s%s%d%s%d&quot;,&quot;200,&quot;, &quot;Register_Address_&quot;,ADDRESS_START+i, &quot;,ustb_test,&quot;, tab_rp_registers[i]); break; case 4:printf(&quot;Address = %d, Value = %d\\n&quot;, ADDRESS_START+i, tab_rp_registers[i]); sprintf(buffer,&quot;%s%s%d%s%d&quot;,&quot;200,&quot;, &quot;Register_Address_&quot;,ADDRESS_START+i, &quot;,ustb_test,&quot;, tab_rp_registers[i]); break; &#125; publish(client, &quot;s/us&quot;,buffer); sleep(1); &#125; &#125; printf(&quot;LOOP: %d, CODE: %d\\n&quot;, nb_loop, CODE); printf(&quot;Read: &quot;); if (nb_fail) printf(&quot;%d FAILS\\n&quot;, nb_fail); else printf(&quot;SUCCESS\\n&quot;); printf(&quot;&gt;&gt;\\n&quot;); &#125; /* Free the memory */ free(tab_rp_registers); /* Close the connection */ modbus_close(ctx); modbus_free(ctx); return 0;&#125;","categories":[{"name":"C","slug":"C","permalink":"http://zhongriqian.github.io/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"http://zhongriqian.github.io/tags/C/"},{"name":"Modbus RTU","slug":"Modbus-RTU","permalink":"http://zhongriqian.github.io/tags/Modbus-RTU/"},{"name":"MQTT","slug":"MQTT","permalink":"http://zhongriqian.github.io/tags/MQTT/"}]},{"title":"Python计算TBS程序","slug":"Python计算TBS程序","date":"2022-05-15T16:00:00.000Z","updated":"2023-01-28T08:53:37.398Z","comments":true,"path":"2022/05/16/Python计算TBS程序/","link":"","permalink":"http://zhongriqian.github.io/2022/05/16/Python%E8%AE%A1%E7%AE%97TBS%E7%A8%8B%E5%BA%8F/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200from openpyxl import load_workbookimport mathclass N_PRB: &quot;&quot;&quot; 由给定参数获得分配给PDSCH的PRB（Physical resource block，物理资源块）数量 &quot;&quot;&quot; def __init__(self, file_path, scs, bw): &quot;&quot;&quot; 创建PRB查询对象 :param file_path: PRB表的路径（该表可由scs和bw查PRB值） :param scs: sub carrier spacing，子载波间隔（kHz） :param bw: bandwidth，载波带宽（MHz） &quot;&quot;&quot; self.table = load_workbook(file_path) self.sheet = self.table[&#x27;Sheet1&#x27;] self.scs = scs self.bw = bw def calculate_N_prb(self): &quot;&quot;&quot; 通过参数scs和bw查表得到PRB（Physical resource block，物理资源块）数量 :return:PRB（Physical resource block，物理资源块）数量 &quot;&quot;&quot; try: for line in range(3, 6): if self.scs == int(self.sheet[&#x27;A&#x27; + str(line)].value): for column in range(66, 78): if self.bw == int(self.sheet[chr(column) + &#x27;1&#x27;].value): N_prb = int(self.sheet[chr(column) + str(line)].value) print(&quot;scs=%dkHz，bw=%dMHz ===&gt; PRB数量=%d&quot; % (self.scs, self.bw, N_prb)) return N_prb except ValueError: print(&quot;calculate_N_prb运行失败，scs=%dkHz,bw=%dMHz无对应PRB值&quot; % (self.scs, self.bw))class TBS: &quot;&quot;&quot; 通过给定参数获得TBS（Transport Block Size，传输块大小）数值 &quot;&quot;&quot; def __init__(self, N_prb, file_path, Imcs): &quot;&quot;&quot; 创建Imcs表对象，相关参数赋值 :param N_prb:PRB（Physical resource block，物理资源块）数量 :param file_path:Imcs表的路径，该表可由Imcs（Modulation and Coding Scheme index，调制与编码策略索引）值 查对应qm（调制阶数）和R（码率） :param Imcs:Imcs（Modulation and Coding Scheme index，调制与编码策略索引） &quot;&quot;&quot; self.N_prb = N_prb self.table = load_workbook(file_path) self.sheet = self.table[&#x27;Sheet1&#x27;] self.N_rb_sc = 12 # 一个RB中的子载波个数 self.N_sh_symb = 13 # 一个时隙中分配给PDSCH的符号数 self.N_prb_oh = 0 # 由高层参数决定 self.N_prb_dmrs = 12 # 一个时隙中一个PRB宽度中DMRS占用的子载波，DMRS tpye1和DMRS type2两种类型 self.Imcs = Imcs # Imcs（Modulation and Coding Scheme index，调制与编码策略索引） def calculate_N_re(self): &quot;&quot;&quot; 计算给定带宽中一个时隙内分配给PDSCH的RE（Resource Element，资源元素）数量 :return: RE（Resource Element，资源元素）数量 &quot;&quot;&quot; try: N_re_t = min(156, self.N_rb_sc * self.N_sh_symb - self.N_prb_dmrs - self.N_prb_oh) N_re = int(N_re_t * self.N_prb) print(&quot;在包含%d个RB的带宽中，一个时隙内分配给PDSCH的RE数量=%d&quot; % (self.N_prb, N_re)) return N_re except TypeError: print(&quot;Calculate_N_re运行失败，重新设置scs与bw的值，以获取可用PRB数量值&quot;) def calculate_N_info(self): &quot;&quot;&quot; 计算信息比特数 :return:信息比特数 &quot;&quot;&quot; try: Nre = self.calculate_N_re() v = 1 for line in range(2, 34): if self.Imcs == int(self.sheet[&#x27;A&#x27; + str(line)].value): qm = int(self.sheet[&#x27;B&#x27; + str(line)].value) R = float(self.sheet[&#x27;c&#x27; + str(line)].value) / 1024 N_info = Nre * qm * v * R print(&quot;MAC层向物理层传输的一个TB中的信息比特数=%d bits&quot; % N_info) return N_info except TypeError: print(&quot;calculate_N_info运行失败，重新设置scs与bw的值，以获取可用PRB数量值&quot;) def calculate_q_N_info(self): &quot;&quot;&quot; 计算信息比特数的量化中间数 :return:信息比特数的量化中间数 &quot;&quot;&quot; try: Ninfo = self.calculate_N_info() if Ninfo &gt; 3824: n = int(math.log((Ninfo - 24), 2) - 5) q_N_info = max(3840, math.pow(2, n) * round((Ninfo - 24) / math.pow(2, n))) else: n = max(3, int(math.log(Ninfo, 2) - 6)) q_N_info = max(24, math.pow(2, n) * round(Ninfo / math.pow(2, n))) print(&quot;信息比特数的量化中间值=%d bits&quot; % q_N_info) return q_N_info except TypeError: print(&quot;calculate_q_N_info运行失败，重新设置scs与bw的值，以获取可用PRB数量值&quot;) def calculate_TBS(self): &quot;&quot;&quot; 计算TBS（Transport Block Size，传输块大小） :return: TBS（Transport Block Size，传输块大小） &quot;&quot;&quot; try: qNinfo = self.calculate_q_N_info() for line in range(2, 34): if self.Imcs == int(self.sheet[&#x27;A&#x27; + str(line)].value): R = float(self.sheet[&#x27;c&#x27; + str(line)].value) / 1024 if R &lt; 0.25: C = math.ceil(float(qNinfo + 24) / 3816) TBS = 8 * C * math.ceil((qNinfo + 24) / (8 * C)) - 24 else: C = math.ceil(float(qNinfo + 24) / 8424) if qNinfo &gt; 8424: TBS = 8 * C * math.ceil((qNinfo + 24) / (8 * C)) - 24 else: TBS = 8 * math.ceil((qNinfo + 24) / (8 * C)) - 24 print(&#x27;TBS = %d bits&#x27; % TBS) return TBS except TypeError: print(&quot;calculate_TBS运行失败，重新设置scs与bw的值，以获取可用PRB数量值&quot;)class N_bits: &quot;&quot;&quot; 计算在给定参数下，一个RB所含的比特数、一个OFDM符号所含比特数 &quot;&quot;&quot; def __init__(self, file_path, xQAM, scs, bw): &quot;&quot;&quot; :param file_path: PRB表的路径（该表可由scs和bw查PRB值） :param xQAM: 调制方式，16QAM, 64QAM and 256QAM :param scs: sub carrier spacing，子载波间隔（kHz） :param bw: bandwidth，载波带宽（MHz） &quot;&quot;&quot; self.table = load_workbook(file_path) self.sheet = self.table[&#x27;Sheet1&#x27;] self.xQAM = xQAM self.scs = scs self.bw = bw def calculate_N_RPB_bits(self): &quot;&quot;&quot; :return: 一个RB所含的比特数 &quot;&quot;&quot; N_prb_bits = math.log(self.xQAM, 2) * 12 print(&quot;选用%dQAM调制，一个RB所含比特数=%d bits&quot; % (self.xQAM, N_prb_bits)) return N_prb_bits def calculate_N_symb_bits(self): &quot;&quot;&quot; :return: 一个OFDM符号所含的比特数 &quot;&quot;&quot; try: for line in range(3, 6): if self.scs == int(self.sheet[&#x27;A&#x27; + str(line)].value): for column in range(66, 78): if self.bw == int(self.sheet[chr(column) + &#x27;1&#x27;].value): N_prb = int(self.sheet[chr(column) + str(line)].value) N_symb_bits = N_prb * math.log(self.xQAM, 2) * 12 print(&quot;scs=%dkHZ，bw=%dMHz，选用%dQAM调制，一个OFDM符号所含比特数=%d bits&quot; % (self.scs, self.bw, self.xQAM, N_symb_bits)) except ValueError: print(&quot;calculate_N_symb_bits运行失败，scs=%dkHz,bw=%dMHz无对应PRB值&quot; % (self.scs, self.bw))if __name__ == &#x27;__main__&#x27;: # 创建N_PRB对象,参数scs=30，bw=100 n = N_PRB(&#x27;maximum_transmission_bandwidth_configuration_Nrb.xlsx&#x27;, 15, 20) # 查询PRB数量 print(&quot;/---------------------------------------------------------------\\\\&quot;) Nprb = n.calculate_N_prb() print(&quot;\\\\---------------------------------------------------------------/&quot;) # 创建TBS对象 TBS1 = TBS(Nprb, &#x27;MCS index table 2 for PDSCH.xlsx&#x27;, 26) # TBS1.calculate_N_re() # TBS1.calculate_N_info() # TBS1.calculate_q_N_info() print(&quot;/---------------------------------------------------------------\\\\&quot;) TBS1.calculate_TBS() print(&quot;\\\\---------------------------------------------------------------/&quot;) # 创建N_bits对象 xQAM_RB = N_bits(&#x27;maximum_transmission_bandwidth_configuration_Nrb.xlsx&#x27;, 64, 30, 20) print(&quot;/---------------------------------------------------------------\\\\&quot;) xQAM_RB.calculate_N_RPB_bits() xQAM_RB.calculate_N_symb_bits() print(&quot;\\\\---------------------------------------------------------------/&quot;)","categories":[{"name":"Python","slug":"Python","permalink":"http://zhongriqian.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://zhongriqian.github.io/tags/Python/"},{"name":"5G","slug":"5G","permalink":"http://zhongriqian.github.io/tags/5G/"},{"name":"TBS","slug":"TBS","permalink":"http://zhongriqian.github.io/tags/TBS/"}]},{"title":"Python+Docker实现人脸识别远程监控系统","slug":"Python+Docker实现人脸识别远程监控系统","date":"2022-05-06T16:00:00.000Z","updated":"2023-01-28T14:54:46.652Z","comments":true,"path":"2022/05/07/Python+Docker实现人脸识别远程监控系统/","link":"","permalink":"http://zhongriqian.github.io/2022/05/07/Python+Docker%E5%AE%9E%E7%8E%B0%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E8%BF%9C%E7%A8%8B%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"说明 本项目包括服务端程序和客户端程序。服务端使用Python OpenCV库实现人脸识别功能，并将添加上识别结果的视频流通过TCP发送给客户端，且支持将上述功能程序封装为Docker容器；客户端程序通过IP+端口接入服务端，接收视频流，实时查看人脸识别结果。客户端可与服务端断开接入后重新连接，不影响服务端功能。 项目文件 tcpsend.py（服务端程序） tcpreceive.py（客户端程序） requirements.txt（项目依赖） train.py（人脸识别模型训练程序） trainer.yml（人脸识别模型） haarcascade_frontalface_alt2.xml（分类器） Dockerfile（构建Docker镜像所需文件） 项目源码 tcpsend.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import socketimport cv2import sysimport osimport numpy as npip###address = (&#x27;ip&#x27;, 5555) # 服务端地址和端口ser = socket.socket(socket.AF_INET, socket.SOCK_STREAM)ser.bind(address)ser.listen(5)# 阻塞式print(&#x27;waiting。。。&#x27;)conn, addr = ser.accept()print(&#x27;建立连接...&#x27;)print(&#x27;连接对象：&#x27;, addr)cap = cv2.VideoCapture(0)# cap = cv2.VideoCapture(0)frames_num=cap.get(7)print(&#x27;视频总帧数：&#x27;,frames_num)print(&#x27;发送目标...&#x27;)count = 0#######加载训练数据集文件recogizer = cv2.face.LBPHFaceRecognizer_create()recogizer.read(&#x27;./trainer.yml&#x27;)names = []warningtime = 0#准备识别的图片def face_detect_demo(img): gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) # 转换为灰度 face_detector = cv2.CascadeClassifier(&#x27;./haarcascade_frontalface_alt2.xml&#x27;) face = face_detector.detectMultiScale(gray, 1.1, 5, cv2.CASCADE_SCALE_IMAGE, (100, 100), (300, 300)) # face=face_detector.detectMultiScale(gray) for x, y, w, h in face: cv2.rectangle(img, (x, y), (x+w, y+h), color=(255, 144, 30), thickness=2) # blue,green,red # cv2.circle(img,center=(x+w//2,y+h//2),radius=w//2,color=(0,255,0),thickness=1) # 人脸识别 ids, confidence = recogizer.predict(gray[y:y + h, x:x + w]) # print(&#x27;标签id:&#x27;,ids,&#x27;置信评分：&#x27;, confidence) if confidence &gt; 80: cv2.putText(img, &#x27;unkonw&#x27;, (x + 10, y - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.75, (255, 144, 30), 2) else: cv2.putText(img, &#x27;dong&#x27;, (x + 10, y - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.75, (255, 144, 30), 2) # cv2.imshow(&#x27;result&#x27;, img) # print(&#x27;bug:&#x27;,ids) return imgdef name(): path = &#x27;./dataset/&#x27; # names = [] imagePaths = [os.path.join(path, f) for f in os.listdir(path)] for imagePath in imagePaths: name = str(os.path.split(imagePath)[1].split(&#x27;.&#x27;, 2)[1]) names.append(name)####name()while True: flag, frame = cap.read() frame = face_detect_demo(frame) # frame = cv2.resize(frame, (1280, 720)) # cv2.imshow(&#x27;send&#x27;, frame) cv2.waitKey(1) count += 1 # 数据打包有很多方式，也可以用json打包 img_encode = cv2.imencode(&#x27;.jpg&#x27;, frame)[1] data_encode = np.array(img_encode) str_encode = data_encode.tostring() try: conn.sendall(str_encode) except : conn, addr = ser.accept() tcpreceive.py 123456789101112131415161718192021222324252627282930import socketimport sysimport cv2import numpy as npimport timeaddress = (&#x27;ip&#x27;, 5555) # 服务端地址和端口cli = socket.socket(socket.AF_INET, socket.SOCK_STREAM)try: cli.connect(address) # 尝试连接服务端except Exception:ip print(&#x27;[!] Server not found or not open&#x27;) sys.exit()frame_count = 1while True: time1 = time.time() if frame_count == 1 else time1 trigger = &#x27;ok&#x27; cli.sendall(trigger.encode()) data = cli.recv(1024*1024*20) image = np.frombuffer(data, np.uint8) image = cv2.imdecode(image, cv2.IMREAD_COLOR) try: cv2.imshow(&#x27;video&#x27;, image) except: continue cv2.waitKey(1) end_time = time.time() time2 = time.time() print(image.shape[:2], int(frame_count / (time2 - time1))) frame_count += 1cli.close() train.py 12345678910111213141516171819202122232425262728import osimport cv2 as cvfrom PIL import Imageimport numpy as npdef getImageAndLabels(path): facesSamples = [] # 储存人脸数据 ids = [] # 尺寸姓名数据 imagePaths = [os.path.join(path, f) for f in os.listdir(path)] # 储存图片信息 face_detector = cv.CascadeClassifier(&#x27;D:/Python/python3.9.8/Lib/site-packages/cv2/data/haarcascade_frontalface_alt2.xml&#x27;) # 加载分类器 for imagePath in imagePaths: # 遍历列表中的图片 PIL_img = Image.open(imagePath).convert(&#x27;L&#x27;) # 打开图片，灰度化(PIL有九种模式：1,L,P,RGB,RGBA,CMYK,YCbCr,YCbCr,I,F) img_numpy = np.array(PIL_img, &#x27;uint8&#x27;) # 将图片转换为数组，以黑白深浅 faces = face_detector.detectMultiScale(img_numpy) # 获取图片人脸特征 id = int(os.path.split(imagePath)[1].split(&#x27;.&#x27;)[0]) # 获取每张图片的id和姓名 for x, y, w, h in faces: ids.append(id) facesSamples.append(img_numpy[y:y+h, x:x+w]) print(&#x27;id:&#x27;, id) print(&#x27;fs:&#x27;, facesSamples) return facesSamples, idsif __name__ == &#x27;__main__&#x27;: path = &#x27;./dataset/&#x27; # 图片路径 faces, ids = getImageAndLabels(path) # 获取图像数组和id标签数据和姓名 recognizer = cv.face.LBPHFaceRecognizer_create() # 加载识别器 recognizer.train(faces, np.array(ids)) # 训练 recognizer.write(&#x27;./trainer/trainer.yml&#x27;) # 保存文件 requirements.txt 1234numpy==1.21.5Pillow==9.1.0opencv-contrib-python==4.5.5.64opencv-python==4.5.5.64 Dockerfile 12345678FROM python:3.7-slimADD ./facerecognitionserver /codeWORKDIR /codeRUN apt-get updateRUN apt-get install -y libgl1-mesa-glxRUN apt-get install -y libglib2.0-devRUN pip install -r requirements.txtCMD [&quot;python&quot;,&quot;/code/tcpsend.py&quot;]","categories":[{"name":"Python","slug":"Python","permalink":"http://zhongriqian.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://zhongriqian.github.io/tags/Python/"},{"name":"Docker","slug":"Docker","permalink":"http://zhongriqian.github.io/tags/Docker/"},{"name":"OpenCV","slug":"OpenCV","permalink":"http://zhongriqian.github.io/tags/OpenCV/"},{"name":"Socket","slug":"Socket","permalink":"http://zhongriqian.github.io/tags/Socket/"}]},{"title":"Python爬取王蛇属蛇类科普网站数据","slug":"Python爬取王蛇属蛇类科普网站数据","date":"2022-03-20T16:00:00.000Z","updated":"2023-01-28T08:53:46.685Z","comments":true,"path":"2022/03/21/Python爬取王蛇属蛇类科普网站数据/","link":"","permalink":"http://zhongriqian.github.io/2022/03/21/Python%E7%88%AC%E5%8F%96%E7%8E%8B%E8%9B%87%E5%B1%9E%E8%9B%87%E7%B1%BB%E7%A7%91%E6%99%AE%E7%BD%91%E7%AB%99%E6%95%B0%E6%8D%AE/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import requestsfrom lxml import etreeimport reimport timeimport osfrom concurrent.futures import ThreadPoolExecutorfrom tqdm import tqdmdef mkdir(path): &quot;&quot;&quot; 创建文件夹 :param path: 文件夹路径 :return: &quot;&quot;&quot; folder = os.path.exists(path) if not folder: os.makedirs(path)def data_save(data): &quot;&quot;&quot; 下载图片并保存图片对应信息 :param data:从网页爬取的元组格式数据 :return: &quot;&quot;&quot; photo_url_all = &quot;https://sites.pitt.edu/~mcs2/herp/&quot; + data[3] # print(photo_url_all) # 获取图片页面内容 resp_photo_page = requests.get(photo_url_all) photo_page_content = resp_photo_page.text photo_page_content_html = etree.HTML(photo_page_content) # xpath获取图片页面内每张图片的下载地址 src = photo_page_content_html.xpath(&#x27;/html/body/p/img/@src&#x27;) # 获取要存放每组图片的文件夹名称，并创建对应名称的文件夹 folder_name = (data[3].split(&quot;/&quot;)[-1]).split(&quot;.&quot;)[0] mkdir(&quot;data/&quot; + folder_name) for itt in src: # 逐张保存 src = &quot;https://sites.pitt.edu/~mcs2/herp/&quot; + itt src_resp = requests.get(src) photo_name = src.split(&quot;/&quot;)[-1] with open(&quot;data/&quot; + folder_name + &#x27;/&#x27; + photo_name, mode=&#x27;wb&#x27;) as f: f.write(src_resp.content) time.sleep(1) # 创建每组图片的信息文本，并写入信息 with open(&quot;data/&quot; + folder_name + &#x27;/&#x27; + folder_name + &#x27;.txt&#x27;, mode=&#x27;a&#x27;) as ff: ff.write(&quot;Scientific Name : %s\\n&quot; % data[0]) ff.write(&quot;Common Name : %s\\n&quot; % data[1]) ff.write(&quot;Adult Length : %s\\n&quot; % data[2])if __name__ == &#x27;__main__&#x27;: url = &quot;https://sites.pitt.edu/~mcs2/herp/Lampropeltis.html&quot; resp = requests.get(url) page_content = resp.text obj = re.compile(r&#x27;&lt;/td&gt;.*?&lt;tr&gt;&#x27; r&#x27;.*?&lt;td nowrap valign = top&gt;(?P&lt;Scientific_Name&gt;.*?)&lt;/td&gt;&#x27; r&#x27;.*?&lt;td valign = top&gt;(?P&lt;Common_Name&gt;.*?)&lt;/td&gt;&#x27; r&#x27;.*?&lt;td nowrap align = right valign = top&gt;(?P&lt;Adult_Length&gt;.*?)&lt;/td&gt;&#x27; r&#x27;.*?&lt;td valign = top&gt;&lt;IMG SRC=&quot;.*?ball.gif&quot;&gt;\\s?&lt;A\\s+HREF=&quot;(?P&lt;Photo&gt;.*?)&quot;&gt;Photo&lt;/A&gt;&#x27;, re.S ) # 返回迭代器 # result = obj.finditer(page_content) # for it in result: # print(it.group(&quot;Scientific_Name&quot;)) # print(it.group(&quot;Common_Name&quot;)) # print(it.group(&quot;Adult_Length&quot;)) # print(it.group(&quot;Photo&quot;)) # 返回列表 result = obj.findall(page_content) # 多线程 # with ThreadPoolExecutor(30) as t: # for n in tqdm(result, &#x27;数据获取中&#x27;): # t.submit(data_save, n) # print(&quot;数据获取完成&quot;) # 单个依次获取 for n in tqdm(result, &#x27;数据获取中&#x27;): data_save(n) print(&quot;数据获取完成&quot;)","categories":[{"name":"Python","slug":"Python","permalink":"http://zhongriqian.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://zhongriqian.github.io/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://zhongriqian.github.io/tags/%E7%88%AC%E8%99%AB/"}]}],"categories":[{"name":"C","slug":"C","permalink":"http://zhongriqian.github.io/categories/C/"},{"name":"Docker","slug":"Docker","permalink":"http://zhongriqian.github.io/categories/Docker/"},{"name":"Linux","slug":"Linux","permalink":"http://zhongriqian.github.io/categories/Linux/"},{"name":"Python","slug":"Python","permalink":"http://zhongriqian.github.io/categories/Python/"}],"tags":[{"name":"EtherCAT","slug":"EtherCAT","permalink":"http://zhongriqian.github.io/tags/EtherCAT/"},{"name":"C","slug":"C","permalink":"http://zhongriqian.github.io/tags/C/"},{"name":"Linux","slug":"Linux","permalink":"http://zhongriqian.github.io/tags/Linux/"},{"name":"Docker","slug":"Docker","permalink":"http://zhongriqian.github.io/tags/Docker/"},{"name":"Socket","slug":"Socket","permalink":"http://zhongriqian.github.io/tags/Socket/"},{"name":"Modbus RTU","slug":"Modbus-RTU","permalink":"http://zhongriqian.github.io/tags/Modbus-RTU/"},{"name":"MQTT","slug":"MQTT","permalink":"http://zhongriqian.github.io/tags/MQTT/"},{"name":"Python","slug":"Python","permalink":"http://zhongriqian.github.io/tags/Python/"},{"name":"5G","slug":"5G","permalink":"http://zhongriqian.github.io/tags/5G/"},{"name":"TBS","slug":"TBS","permalink":"http://zhongriqian.github.io/tags/TBS/"},{"name":"OpenCV","slug":"OpenCV","permalink":"http://zhongriqian.github.io/tags/OpenCV/"},{"name":"爬虫","slug":"爬虫","permalink":"http://zhongriqian.github.io/tags/%E7%88%AC%E8%99%AB/"}]}