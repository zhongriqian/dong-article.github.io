{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"Hello World","slug":"hello-world","date":"2023-01-27T05:01:22.874Z","updated":"2023-01-27T15:10:15.603Z","comments":true,"path":"2023/01/27/hello-world/","link":"","permalink":"http://example.com/2023/01/27/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"数采网关程序——Modbus-RTU与MQTT协议转换","slug":"数采网关程序——Modbus-RTU与MQTT协议转换","date":"2022-08-16T16:00:00.000Z","updated":"2023-01-28T07:44:38.114Z","comments":true,"path":"2022/08/17/数采网关程序——Modbus-RTU与MQTT协议转换/","link":"","permalink":"http://example.com/2022/08/17/%E6%95%B0%E9%87%87%E7%BD%91%E5%85%B3%E7%A8%8B%E5%BA%8F%E2%80%94%E2%80%94Modbus-RTU%E4%B8%8EMQTT%E5%8D%8F%E8%AE%AE%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#include &lt;modbus.h&gt;#include &lt;unistd.h&gt;#include &lt;MQTTClient.h&gt;#define ADDRESS &quot;&quot;#define CLIENTID &quot;&quot;#define LOOP 10#define SERVER_ID 1#define ADDRESS_START 0#define ADDRESS_END 4#define CODE 1void publish(MQTTClient client, char* topic, char* payload) &#123; MQTTClient_message pubmsg = MQTTClient_message_initializer; pubmsg.payload = payload; pubmsg.payloadlen = strlen(pubmsg.payload); pubmsg.qos = 2; pubmsg.retained = 0; MQTTClient_deliveryToken token; MQTTClient_publishMessage(client, topic, &amp;pubmsg, &amp;token); MQTTClient_waitForCompletion(client, token, 1000L); printf(&quot;Message &#x27;%s&#x27; with delivery token %d delivered\\n&quot;, payload, token);&#125;int on_message(void *context, char *topicName, int topicLen, MQTTClient_message *message) &#123; char* payload = message-&gt;payload; printf(&quot;Received operation %s\\n&quot;, payload); MQTTClient_freeMessage(&amp;message); MQTTClient_free(topicName); return 1;&#125;int main(void)&#123; modbus_t *ctx; int rc; int nb_fail; int nb_loop; int addr; int nb; uint8_t *tab_rp_bits; uint16_t *tab_rp_registers; char buffer[100]; /*MQTT initialize*/ MQTTClient client; MQTTClient_create(&amp;client, ADDRESS, CLIENTID, MQTTCLIENT_PERSISTENCE_NONE, NULL); MQTTClient_connectOptions conn_opts = MQTTClient_connectOptions_initializer; conn_opts.username = &quot;&quot;; conn_opts.password = &quot;&quot;; MQTTClient_setCallbacks(client, NULL, NULL, on_message, NULL); int rc_mqtt; if ((rc_mqtt = MQTTClient_connect(client, &amp;conn_opts)) != MQTTCLIENT_SUCCESS) &#123; printf(&quot;Failed to connect, return code %d\\n&quot;, rc_mqtt); exit(-1); &#125; //create device publish(client, &quot;s/us&quot;, &quot;100,USTB_TEST,c8y_MQTTDevice&quot;); //set hardware information publish(client, &quot;s/us&quot;, &quot;110,S123456789,MQTT test model,Rev0.1&quot;); //listen for operation MQTTClient_subscribe(client, &quot;s/ds&quot;, 0); /* RTU */ ctx = modbus_new_rtu(&quot;/dev/ttyS1&quot;, 19200, &#x27;N&#x27;, 8, 1); modbus_set_slave(ctx, SERVER_ID); /* TCP */// ctx = modbus_new_tcp(&quot;127.0.0.1&quot;, 1502);// ctx = modbus_new_tcp(&quot;192.168.72.61&quot;, 502);// modbus_set_debug(ctx, TRUE); if (modbus_connect(ctx) == -1) &#123; fprintf(stderr, &quot;Connection failed: %s\\n&quot;, modbus_strerror(errno)); modbus_free(ctx); return -1; &#125; nb = ADDRESS_END - ADDRESS_START; if(CODE == 1 || CODE == 2)&#123; tab_rp_bits = (uint8_t *) malloc(nb * sizeof(uint8_t)); memset(tab_rp_bits, 0, nb * sizeof(uint8_t)); &#125; else&#123; tab_rp_registers = (uint16_t *) malloc(nb * sizeof(uint16_t)); memset(tab_rp_registers, 0, nb * sizeof(uint16_t)); &#125; nb_loop = nb_fail = 0; while (nb_loop++ &lt; LOOP) &#123; int i; addr = ADDRESS_START; switch(CODE)&#123; case 1: rc = modbus_read_bits(ctx, addr, nb, tab_rp_bits);break; // modbus功能码01 case 2: rc = modbus_read_input_bits(ctx, addr, nb, tab_rp_bits);break; // modbus功能码02 case 3: rc = modbus_read_registers(ctx, addr, nb, tab_rp_registers);break; // modbus功能码03 case 4: rc = modbus_read_input_registers(ctx, addr, nb, tab_rp_registers);break; // modbus功能码04 default: rc = 0; &#125; printf(&quot;&lt;&lt;\\n&quot;); if (rc != nb) &#123; printf(&quot;ERROR modbus_read_registers (%d)\\n&quot;, rc); printf(&quot;Address = %d, nb = %d\\n&quot;, addr, nb); nb_fail++; &#125; else &#123; for (i=0; i&lt;nb; i++) &#123; buffer[0] = &#x27;\\0&#x27;; switch(CODE)&#123; case 1: printf(&quot;Address = %d, Status = %X\\n&quot;, addr+i, tab_rp_bits[i]); sprintf(buffer,&quot;%s%s%d%s%d&quot;,&quot;200,&quot;, &quot;Register_Address_&quot;,ADDRESS_START+i, &quot;,ustb_test,&quot;, tab_rp_bits[i]); break; case 2:printf(&quot;Address = %d, Status = %X\\n&quot;, addr+i, tab_rp_bits[i]); sprintf(buffer,&quot;%s%s%d%s%d&quot;,&quot;200,&quot;, &quot;Register_Address_&quot;,ADDRESS_START+i, &quot;,ustb_test,&quot;, tab_rp_bits[i]); break; case 3:printf(&quot;Address = %d, Value = %d\\n&quot;, ADDRESS_START+i, tab_rp_registers[i]); sprintf(buffer,&quot;%s%s%d%s%d&quot;,&quot;200,&quot;, &quot;Register_Address_&quot;,ADDRESS_START+i, &quot;,ustb_test,&quot;, tab_rp_registers[i]); break; case 4:printf(&quot;Address = %d, Value = %d\\n&quot;, ADDRESS_START+i, tab_rp_registers[i]); sprintf(buffer,&quot;%s%s%d%s%d&quot;,&quot;200,&quot;, &quot;Register_Address_&quot;,ADDRESS_START+i, &quot;,ustb_test,&quot;, tab_rp_registers[i]); break; &#125; publish(client, &quot;s/us&quot;,buffer); sleep(1); &#125; &#125; printf(&quot;LOOP: %d, CODE: %d\\n&quot;, nb_loop, CODE); printf(&quot;Read: &quot;); if (nb_fail) printf(&quot;%d FAILS\\n&quot;, nb_fail); else printf(&quot;SUCCESS\\n&quot;); printf(&quot;&gt;&gt;\\n&quot;); &#125; /* Free the memory */ free(tab_rp_registers); /* Close the connection */ modbus_close(ctx); modbus_free(ctx); return 0;&#125;","categories":[{"name":"C","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C,Modbus RTU,MQTT","slug":"C-Modbus-RTU-MQTT","permalink":"http://example.com/tags/C-Modbus-RTU-MQTT/"}]},{"title":"Python计算TBS程序","slug":"Python计算TBS程序","date":"2022-05-15T16:00:00.000Z","updated":"2023-01-28T07:17:17.062Z","comments":true,"path":"2022/05/16/Python计算TBS程序/","link":"","permalink":"http://example.com/2022/05/16/Python%E8%AE%A1%E7%AE%97TBS%E7%A8%8B%E5%BA%8F/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200from openpyxl import load_workbookimport mathclass N_PRB: &quot;&quot;&quot; 由给定参数获得分配给PDSCH的PRB（Physical resource block，物理资源块）数量 &quot;&quot;&quot; def __init__(self, file_path, scs, bw): &quot;&quot;&quot; 创建PRB查询对象 :param file_path: PRB表的路径（该表可由scs和bw查PRB值） :param scs: sub carrier spacing，子载波间隔（kHz） :param bw: bandwidth，载波带宽（MHz） &quot;&quot;&quot; self.table = load_workbook(file_path) self.sheet = self.table[&#x27;Sheet1&#x27;] self.scs = scs self.bw = bw def calculate_N_prb(self): &quot;&quot;&quot; 通过参数scs和bw查表得到PRB（Physical resource block，物理资源块）数量 :return:PRB（Physical resource block，物理资源块）数量 &quot;&quot;&quot; try: for line in range(3, 6): if self.scs == int(self.sheet[&#x27;A&#x27; + str(line)].value): for column in range(66, 78): if self.bw == int(self.sheet[chr(column) + &#x27;1&#x27;].value): N_prb = int(self.sheet[chr(column) + str(line)].value) print(&quot;scs=%dkHz，bw=%dMHz ===&gt; PRB数量=%d&quot; % (self.scs, self.bw, N_prb)) return N_prb except ValueError: print(&quot;calculate_N_prb运行失败，scs=%dkHz,bw=%dMHz无对应PRB值&quot; % (self.scs, self.bw))class TBS: &quot;&quot;&quot; 通过给定参数获得TBS（Transport Block Size，传输块大小）数值 &quot;&quot;&quot; def __init__(self, N_prb, file_path, Imcs): &quot;&quot;&quot; 创建Imcs表对象，相关参数赋值 :param N_prb:PRB（Physical resource block，物理资源块）数量 :param file_path:Imcs表的路径，该表可由Imcs（Modulation and Coding Scheme index，调制与编码策略索引）值 查对应qm（调制阶数）和R（码率） :param Imcs:Imcs（Modulation and Coding Scheme index，调制与编码策略索引） &quot;&quot;&quot; self.N_prb = N_prb self.table = load_workbook(file_path) self.sheet = self.table[&#x27;Sheet1&#x27;] self.N_rb_sc = 12 # 一个RB中的子载波个数 self.N_sh_symb = 13 # 一个时隙中分配给PDSCH的符号数 self.N_prb_oh = 0 # 由高层参数决定 self.N_prb_dmrs = 12 # 一个时隙中一个PRB宽度中DMRS占用的子载波，DMRS tpye1和DMRS type2两种类型 self.Imcs = Imcs # Imcs（Modulation and Coding Scheme index，调制与编码策略索引） def calculate_N_re(self): &quot;&quot;&quot; 计算给定带宽中一个时隙内分配给PDSCH的RE（Resource Element，资源元素）数量 :return: RE（Resource Element，资源元素）数量 &quot;&quot;&quot; try: N_re_t = min(156, self.N_rb_sc * self.N_sh_symb - self.N_prb_dmrs - self.N_prb_oh) N_re = int(N_re_t * self.N_prb) print(&quot;在包含%d个RB的带宽中，一个时隙内分配给PDSCH的RE数量=%d&quot; % (self.N_prb, N_re)) return N_re except TypeError: print(&quot;Calculate_N_re运行失败，重新设置scs与bw的值，以获取可用PRB数量值&quot;) def calculate_N_info(self): &quot;&quot;&quot; 计算信息比特数 :return:信息比特数 &quot;&quot;&quot; try: Nre = self.calculate_N_re() v = 1 for line in range(2, 34): if self.Imcs == int(self.sheet[&#x27;A&#x27; + str(line)].value): qm = int(self.sheet[&#x27;B&#x27; + str(line)].value) R = float(self.sheet[&#x27;c&#x27; + str(line)].value) / 1024 N_info = Nre * qm * v * R print(&quot;MAC层向物理层传输的一个TB中的信息比特数=%d bits&quot; % N_info) return N_info except TypeError: print(&quot;calculate_N_info运行失败，重新设置scs与bw的值，以获取可用PRB数量值&quot;) def calculate_q_N_info(self): &quot;&quot;&quot; 计算信息比特数的量化中间数 :return:信息比特数的量化中间数 &quot;&quot;&quot; try: Ninfo = self.calculate_N_info() if Ninfo &gt; 3824: n = int(math.log((Ninfo - 24), 2) - 5) q_N_info = max(3840, math.pow(2, n) * round((Ninfo - 24) / math.pow(2, n))) else: n = max(3, int(math.log(Ninfo, 2) - 6)) q_N_info = max(24, math.pow(2, n) * round(Ninfo / math.pow(2, n))) print(&quot;信息比特数的量化中间值=%d bits&quot; % q_N_info) return q_N_info except TypeError: print(&quot;calculate_q_N_info运行失败，重新设置scs与bw的值，以获取可用PRB数量值&quot;) def calculate_TBS(self): &quot;&quot;&quot; 计算TBS（Transport Block Size，传输块大小） :return: TBS（Transport Block Size，传输块大小） &quot;&quot;&quot; try: qNinfo = self.calculate_q_N_info() for line in range(2, 34): if self.Imcs == int(self.sheet[&#x27;A&#x27; + str(line)].value): R = float(self.sheet[&#x27;c&#x27; + str(line)].value) / 1024 if R &lt; 0.25: C = math.ceil(float(qNinfo + 24) / 3816) TBS = 8 * C * math.ceil((qNinfo + 24) / (8 * C)) - 24 else: C = math.ceil(float(qNinfo + 24) / 8424) if qNinfo &gt; 8424: TBS = 8 * C * math.ceil((qNinfo + 24) / (8 * C)) - 24 else: TBS = 8 * math.ceil((qNinfo + 24) / (8 * C)) - 24 print(&#x27;TBS = %d bits&#x27; % TBS) return TBS except TypeError: print(&quot;calculate_TBS运行失败，重新设置scs与bw的值，以获取可用PRB数量值&quot;)class N_bits: &quot;&quot;&quot; 计算在给定参数下，一个RB所含的比特数、一个OFDM符号所含比特数 &quot;&quot;&quot; def __init__(self, file_path, xQAM, scs, bw): &quot;&quot;&quot; :param file_path: PRB表的路径（该表可由scs和bw查PRB值） :param xQAM: 调制方式，16QAM, 64QAM and 256QAM :param scs: sub carrier spacing，子载波间隔（kHz） :param bw: bandwidth，载波带宽（MHz） &quot;&quot;&quot; self.table = load_workbook(file_path) self.sheet = self.table[&#x27;Sheet1&#x27;] self.xQAM = xQAM self.scs = scs self.bw = bw def calculate_N_RPB_bits(self): &quot;&quot;&quot; :return: 一个RB所含的比特数 &quot;&quot;&quot; N_prb_bits = math.log(self.xQAM, 2) * 12 print(&quot;选用%dQAM调制，一个RB所含比特数=%d bits&quot; % (self.xQAM, N_prb_bits)) return N_prb_bits def calculate_N_symb_bits(self): &quot;&quot;&quot; :return: 一个OFDM符号所含的比特数 &quot;&quot;&quot; try: for line in range(3, 6): if self.scs == int(self.sheet[&#x27;A&#x27; + str(line)].value): for column in range(66, 78): if self.bw == int(self.sheet[chr(column) + &#x27;1&#x27;].value): N_prb = int(self.sheet[chr(column) + str(line)].value) N_symb_bits = N_prb * math.log(self.xQAM, 2) * 12 print(&quot;scs=%dkHZ，bw=%dMHz，选用%dQAM调制，一个OFDM符号所含比特数=%d bits&quot; % (self.scs, self.bw, self.xQAM, N_symb_bits)) except ValueError: print(&quot;calculate_N_symb_bits运行失败，scs=%dkHz,bw=%dMHz无对应PRB值&quot; % (self.scs, self.bw))if __name__ == &#x27;__main__&#x27;: # 创建N_PRB对象,参数scs=30，bw=100 n = N_PRB(&#x27;maximum_transmission_bandwidth_configuration_Nrb.xlsx&#x27;, 15, 20) # 查询PRB数量 print(&quot;/---------------------------------------------------------------\\\\&quot;) Nprb = n.calculate_N_prb() print(&quot;\\\\---------------------------------------------------------------/&quot;) # 创建TBS对象 TBS1 = TBS(Nprb, &#x27;MCS index table 2 for PDSCH.xlsx&#x27;, 26) # TBS1.calculate_N_re() # TBS1.calculate_N_info() # TBS1.calculate_q_N_info() print(&quot;/---------------------------------------------------------------\\\\&quot;) TBS1.calculate_TBS() print(&quot;\\\\---------------------------------------------------------------/&quot;) # 创建N_bits对象 xQAM_RB = N_bits(&#x27;maximum_transmission_bandwidth_configuration_Nrb.xlsx&#x27;, 64, 30, 20) print(&quot;/---------------------------------------------------------------\\\\&quot;) xQAM_RB.calculate_N_RPB_bits() xQAM_RB.calculate_N_symb_bits() print(&quot;\\\\---------------------------------------------------------------/&quot;)","categories":[],"tags":[]},{"title":"Python+Docker实现人脸识别远程监控系统","slug":"Python+Docker实现人脸识别远程监控系统","date":"2022-05-06T16:00:00.000Z","updated":"2023-01-28T06:28:55.903Z","comments":true,"path":"2022/05/07/Python+Docker实现人脸识别远程监控系统/","link":"","permalink":"http://example.com/2022/05/07/Python+Docker%E5%AE%9E%E7%8E%B0%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E8%BF%9C%E7%A8%8B%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"说明本项目包括服务端程序和客户端程序。服务端使用Python OpenCV库实现人脸识别功能，并将添加上识别结果的视频流通过TCP发送给客户端，且支持将上述功能程序封装为Docker容器；客户端程序通过IP+端口接入服务端，接收视频流，实时查看人脸识别结果。客户端可与服务端断开接入后重新连接，不影响服务端功能。 项目文件 tcpsend.py（服务端程序） tcpreceive.py（客户端程序） requirements.txt（项目依赖） train.py（人脸识别模型训练程序） trainer.yml（人脸识别模型） haarcascade_frontalface_alt2.xml（分类器） Dockerfile（构建Docker镜像所需文件） 项目源码tcpsend.py1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import socketimport cv2import sysimport osimport numpy as npip###address = (&#x27;ip&#x27;, 5555) # 服务端地址和端口ser = socket.socket(socket.AF_INET, socket.SOCK_STREAM)ser.bind(address)ser.listen(5)# 阻塞式print(&#x27;waiting。。。&#x27;)conn, addr = ser.accept()print(&#x27;建立连接...&#x27;)print(&#x27;连接对象：&#x27;, addr)cap = cv2.VideoCapture(0)# cap = cv2.VideoCapture(0)frames_num=cap.get(7)print(&#x27;视频总帧数：&#x27;,frames_num)print(&#x27;发送目标...&#x27;)count = 0#######加载训练数据集文件recogizer = cv2.face.LBPHFaceRecognizer_create()recogizer.read(&#x27;./trainer.yml&#x27;)names = []warningtime = 0#准备识别的图片def face_detect_demo(img): gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) # 转换为灰度 face_detector = cv2.CascadeClassifier(&#x27;./haarcascade_frontalface_alt2.xml&#x27;) face = face_detector.detectMultiScale(gray, 1.1, 5, cv2.CASCADE_SCALE_IMAGE, (100, 100), (300, 300)) # face=face_detector.detectMultiScale(gray) for x, y, w, h in face: cv2.rectangle(img, (x, y), (x+w, y+h), color=(255, 144, 30), thickness=2) # blue,green,red # cv2.circle(img,center=(x+w//2,y+h//2),radius=w//2,color=(0,255,0),thickness=1) # 人脸识别 ids, confidence = recogizer.predict(gray[y:y + h, x:x + w]) # print(&#x27;标签id:&#x27;,ids,&#x27;置信评分：&#x27;, confidence) if confidence &gt; 80: cv2.putText(img, &#x27;unkonw&#x27;, (x + 10, y - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.75, (255, 144, 30), 2) else: cv2.putText(img, &#x27;dong&#x27;, (x + 10, y - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.75, (255, 144, 30), 2) # cv2.imshow(&#x27;result&#x27;, img) # print(&#x27;bug:&#x27;,ids) return imgdef name(): path = &#x27;./dataset/&#x27; # names = [] imagePaths = [os.path.join(path, f) for f in os.listdir(path)] for imagePath in imagePaths: name = str(os.path.split(imagePath)[1].split(&#x27;.&#x27;, 2)[1]) names.append(name)####name()while True: flag, frame = cap.read() frame = face_detect_demo(frame) # frame = cv2.resize(frame, (1280, 720)) # cv2.imshow(&#x27;send&#x27;, frame) cv2.waitKey(1) count += 1 # 数据打包有很多方式，也可以用json打包 img_encode = cv2.imencode(&#x27;.jpg&#x27;, frame)[1] data_encode = np.array(img_encode) str_encode = data_encode.tostring() try: conn.sendall(str_encode) except : conn, addr = ser.accept() tcpreceive.py123456789101112131415161718192021222324252627282930import socketimport sysimport cv2import numpy as npimport timeaddress = (&#x27;ip&#x27;, 5555) # 服务端地址和端口cli = socket.socket(socket.AF_INET, socket.SOCK_STREAM)try: cli.connect(address) # 尝试连接服务端except Exception:ip print(&#x27;[!] Server not found or not open&#x27;) sys.exit()frame_count = 1while True: time1 = time.time() if frame_count == 1 else time1 trigger = &#x27;ok&#x27; cli.sendall(trigger.encode()) data = cli.recv(1024*1024*20) image = np.frombuffer(data, np.uint8) image = cv2.imdecode(image, cv2.IMREAD_COLOR) try: cv2.imshow(&#x27;video&#x27;, image) except: continue cv2.waitKey(1) end_time = time.time() time2 = time.time() print(image.shape[:2], int(frame_count / (time2 - time1))) frame_count += 1cli.close() train.py12345678910111213141516171819202122232425262728import osimport cv2 as cvfrom PIL import Imageimport numpy as npdef getImageAndLabels(path): facesSamples = [] # 储存人脸数据 ids = [] # 尺寸姓名数据 imagePaths = [os.path.join(path, f) for f in os.listdir(path)] # 储存图片信息 face_detector = cv.CascadeClassifier(&#x27;D:/Python/python3.9.8/Lib/site-packages/cv2/data/haarcascade_frontalface_alt2.xml&#x27;) # 加载分类器 for imagePath in imagePaths: # 遍历列表中的图片 PIL_img = Image.open(imagePath).convert(&#x27;L&#x27;) # 打开图片，灰度化(PIL有九种模式：1,L,P,RGB,RGBA,CMYK,YCbCr,YCbCr,I,F) img_numpy = np.array(PIL_img, &#x27;uint8&#x27;) # 将图片转换为数组，以黑白深浅 faces = face_detector.detectMultiScale(img_numpy) # 获取图片人脸特征 id = int(os.path.split(imagePath)[1].split(&#x27;.&#x27;)[0]) # 获取每张图片的id和姓名 for x, y, w, h in faces: ids.append(id) facesSamples.append(img_numpy[y:y+h, x:x+w]) print(&#x27;id:&#x27;, id) print(&#x27;fs:&#x27;, facesSamples) return facesSamples, idsif __name__ == &#x27;__main__&#x27;: path = &#x27;./dataset/&#x27; # 图片路径 faces, ids = getImageAndLabels(path) # 获取图像数组和id标签数据和姓名 recognizer = cv.face.LBPHFaceRecognizer_create() # 加载识别器 recognizer.train(faces, np.array(ids)) # 训练 recognizer.write(&#x27;./trainer/trainer.yml&#x27;) # 保存文件 requirements.txt1234numpy==1.21.5Pillow==9.1.0opencv-contrib-python==4.5.5.64opencv-python==4.5.5.64 Dockerfile12345678FROM python:3.7-slimADD ./facerecognitionserver /codeWORKDIR /codeRUN apt-get updateRUN apt-get install -y libgl1-mesa-glxRUN apt-get install -y libglib2.0-devRUN pip install -r requirements.txtCMD [&quot;python&quot;,&quot;/code/tcpsend.py&quot;]","categories":[],"tags":[]},{"title":"Python爬取王蛇属蛇类科普网站数据","slug":"Python爬取王蛇属蛇类科普网站数据","date":"2022-03-20T16:00:00.000Z","updated":"2023-01-28T07:19:47.884Z","comments":true,"path":"2022/03/21/Python爬取王蛇属蛇类科普网站数据/","link":"","permalink":"http://example.com/2022/03/21/Python%E7%88%AC%E5%8F%96%E7%8E%8B%E8%9B%87%E5%B1%9E%E8%9B%87%E7%B1%BB%E7%A7%91%E6%99%AE%E7%BD%91%E7%AB%99%E6%95%B0%E6%8D%AE/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import requestsfrom lxml import etreeimport reimport timeimport osfrom concurrent.futures import ThreadPoolExecutorfrom tqdm import tqdmdef mkdir(path): &quot;&quot;&quot; 创建文件夹 :param path: 文件夹路径 :return: &quot;&quot;&quot; folder = os.path.exists(path) if not folder: os.makedirs(path)def data_save(data): &quot;&quot;&quot; 下载图片并保存图片对应信息 :param data:从网页爬取的元组格式数据 :return: &quot;&quot;&quot; photo_url_all = &quot;https://sites.pitt.edu/~mcs2/herp/&quot; + data[3] # print(photo_url_all) # 获取图片页面内容 resp_photo_page = requests.get(photo_url_all) photo_page_content = resp_photo_page.text photo_page_content_html = etree.HTML(photo_page_content) # xpath获取图片页面内每张图片的下载地址 src = photo_page_content_html.xpath(&#x27;/html/body/p/img/@src&#x27;) # 获取要存放每组图片的文件夹名称，并创建对应名称的文件夹 folder_name = (data[3].split(&quot;/&quot;)[-1]).split(&quot;.&quot;)[0] mkdir(&quot;data/&quot; + folder_name) for itt in src: # 逐张保存 src = &quot;https://sites.pitt.edu/~mcs2/herp/&quot; + itt src_resp = requests.get(src) photo_name = src.split(&quot;/&quot;)[-1] with open(&quot;data/&quot; + folder_name + &#x27;/&#x27; + photo_name, mode=&#x27;wb&#x27;) as f: f.write(src_resp.content) time.sleep(1) # 创建每组图片的信息文本，并写入信息 with open(&quot;data/&quot; + folder_name + &#x27;/&#x27; + folder_name + &#x27;.txt&#x27;, mode=&#x27;a&#x27;) as ff: ff.write(&quot;Scientific Name : %s\\n&quot; % data[0]) ff.write(&quot;Common Name : %s\\n&quot; % data[1]) ff.write(&quot;Adult Length : %s\\n&quot; % data[2])if __name__ == &#x27;__main__&#x27;: url = &quot;https://sites.pitt.edu/~mcs2/herp/Lampropeltis.html&quot; resp = requests.get(url) page_content = resp.text obj = re.compile(r&#x27;&lt;/td&gt;.*?&lt;tr&gt;&#x27; r&#x27;.*?&lt;td nowrap valign = top&gt;(?P&lt;Scientific_Name&gt;.*?)&lt;/td&gt;&#x27; r&#x27;.*?&lt;td valign = top&gt;(?P&lt;Common_Name&gt;.*?)&lt;/td&gt;&#x27; r&#x27;.*?&lt;td nowrap align = right valign = top&gt;(?P&lt;Adult_Length&gt;.*?)&lt;/td&gt;&#x27; r&#x27;.*?&lt;td valign = top&gt;&lt;IMG SRC=&quot;.*?ball.gif&quot;&gt;\\s?&lt;A\\s+HREF=&quot;(?P&lt;Photo&gt;.*?)&quot;&gt;Photo&lt;/A&gt;&#x27;, re.S ) # 返回迭代器 # result = obj.finditer(page_content) # for it in result: # print(it.group(&quot;Scientific_Name&quot;)) # print(it.group(&quot;Common_Name&quot;)) # print(it.group(&quot;Adult_Length&quot;)) # print(it.group(&quot;Photo&quot;)) # 返回列表 result = obj.findall(page_content) # 多线程 # with ThreadPoolExecutor(30) as t: # for n in tqdm(result, &#x27;数据获取中&#x27;): # t.submit(data_save, n) # print(&quot;数据获取完成&quot;) # 单个依次获取 for n in tqdm(result, &#x27;数据获取中&#x27;): data_save(n) print(&quot;数据获取完成&quot;)","categories":[],"tags":[]}],"categories":[{"name":"C","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C,Modbus RTU,MQTT","slug":"C-Modbus-RTU-MQTT","permalink":"http://example.com/tags/C-Modbus-RTU-MQTT/"}]}