{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://zhongriqian.github.io","root":"/"},"pages":[{"title":"归档","date":"2023-01-28T07:48:11.000Z","updated":"2023-01-28T08:03:42.358Z","comments":true,"path":"archives/index.html","permalink":"http://zhongriqian.github.io/archives/index.html","excerpt":"","text":""},{"title":"分类","date":"2023-01-28T07:54:51.000Z","updated":"2023-01-28T08:31:23.746Z","comments":true,"path":"categories/index.html","permalink":"http://zhongriqian.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-01-28T07:54:36.000Z","updated":"2023-01-28T08:31:25.384Z","comments":true,"path":"tags/index.html","permalink":"http://zhongriqian.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"基于花生壳和OPEN VPN远程访问树莓派","slug":"基于花生壳和OPEN_VPN实现远程访问移动网络树莓派","date":"2023-11-20T16:00:00.000Z","updated":"2023-11-21T03:27:11.737Z","comments":true,"path":"2023/11/21/基于花生壳和OPEN_VPN实现远程访问移动网络树莓派/","link":"","permalink":"http://zhongriqian.github.io/2023/11/21/%E5%9F%BA%E4%BA%8E%E8%8A%B1%E7%94%9F%E5%A3%B3%E5%92%8COPEN_VPN%E5%AE%9E%E7%8E%B0%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C%E6%A0%91%E8%8E%93%E6%B4%BE/","excerpt":"","text":"前言使用open vpn软件，可以在能够访问互联网的树莓派、PC上安装vpn客户端，然后在公网服务器上安装vpn服务端，从而在三者之间组建虚拟局域网，实现PC远程访问树莓派，但这种方式通常需要购买具备公网IP的云服务器来搭建vpn服务端。本文将open vpn与花生壳配合使用，仅利用花生壳免费功能来实现PC远程访问树莓派，且仅需占用树莓派1194端口用于vpn服务，其他端口可任意使用。 方案原理 实施步骤1、花生壳配置a、树莓派安装花生壳123456# 下载地址https://hsk.oray.com/download# 下载后将deb安装包上传到树莓派# 安装dpkg -i xxxx.deb 1# 安装成功后，会显示设备SN码，默认密码以及远程管理地址 b、注册花生壳账户并登录略 c、花生壳管理平台添加设备12# 进入花生壳管理平台，在左侧菜单栏选择&quot;设备列表&quot;# 使用设备SN码、默认密码添加树莓派 d、花生壳管理平台配置内网穿透1234# 在花生壳管理平台，左侧菜单栏选择&quot;内网穿透&quot;# 点击添加映射# 花生壳免费提供两条映射，在此使用一条用于配置VPN服务映射# 如下图，映射类型选择TCP；TCP类型选择普通TCP；外网域名默认域名；外网端口选择动态端口即可（不用付费）；内网主机填写运营商为树莓派分配的IP；内网端口填写1194（open vpn服务端口） 123# 完成后点击确认即可# 然后可在“内网穿透”页面中，点击刚才新建映射后面的“诊断”选项，查看花生壳内网穿透映射配置是否正常# 如果有问题，检查树莓派是否接入互联网，运营商是否有给树莓派分配ip，以及映射配置信息填写是否正确 1# 上图中外网地址47xxxx.fun就是后续vpn客户端访问树莓派vpn服务端使用的地址，47557是端口号 2、树莓派-vpn服务端配置a、安装open vpn和证书生成工具12apt install -y openvpnapt install -y openvpn b、制作相关证书CA证书1234567891011121314# 进入openvpn文件夹cd /etc/openvpn/# 将easy-rsa文件夹复制到openvpn文件家下cp -r /usr/share/easy-rsa/ /etc/openvpn/# 进入/etc/openvpn/easy-rsa/目录下cd /etc/openvpn/easy-rsa/# 初始化目录./easyrsa init-pki# 创建根证书，nopss表示不加密，遇到“Common Name (eg: your user, host, or server name) [Easy-RSA CA]:”回车即可./easyrsa build-ca nopass Server端证书12345# 创建服务端证书，server111是自定义的服务端名称，中间遇到“Common Name (eg: your user, host, or server name) [server111]:”回车即可./easyrsa gen-req server111 nopass# 给服务端证书签名，中间遇到“ Confirm request details:”输入yes即可./easyrsa sign-req server server111 12# 使用build-server-full参数可直接完成上述创建证书和签名两个步骤./easyrsa build-server-full server111 nopass Client端证书12345# 创建客户端证书，client1为自定义的客户端名称，执行过程中间回车即可./easyrsa gen-req client1 nopass# 给客户端证书签名，中间遇到“ Confirm request details:”输入yes即可./easyrsa sign-req client client1 12# 使用build-client-full参数可直接完成上述创建证书和签名两个步骤./easyrsa build-client-full client1 nopass Diffie-Hellman1./easyrsa gen-dh TLS认证密钥1openvpn --genkey --secret ta.key 整理所有证书到指定文件夹12345678910111213141516mkdir /etc/openvpn/keyscp /etc/openvpn/easy-rsa/ta.key /etc/openvpn/keys/cp /etc/openvpn/easy-rsa/pki/ca.crt /etc/openvpn/keyscp /etc/openvpn/easy-rsa/pki/dh.pem /etc/openvpn/keyscp /etc/openvpn/easy-rsa/pki/issued/server111.crt /etc/openvpn/keyscp /etc/openvpn/easy-rsa/pki/private/server111.key /etc/openvpn/keyscp /etc/openvpn/easy-rsa/pki/issued/client1.crt /etc/openvpn/keyscp /etc/openvpn/easy-rsa/pki/private/client1.key /etc/openvpn/keyscp /etc/openvpn/easy-rsa/pki/issued/client2.crt /etc/openvpn/keyscp /etc/openvpn/easy-rsa/pki/private/client2.key /etc/openvpn/keys c、创建服务端配置文件123456789# 进入指定文件夹下，解压出server.confcd /usr/share/doc/openvpn/examples/sample-config-filesgzip -d /usr/share/doc/openvpn/examples/sample-config-files/server.conf.gz# 复制server.conf到/etc/openvpn/keyscp /usr/share/doc/openvpn/examples/sample-config-files/server.conf /etc/openvpn/keys/# 修改server.conf中的配置，具体如下# &quot;;&quot;是注释符号，加&quot;;&quot;的行不会起作用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677;local a.b.c.dport 1194proto tcp;proto udp;dev tapdev tun;dev-node MyTap# 如果执行openvpn开启命令时所在的路径就是下列文件的所在路径，只写文件名即可，否则需要写绝对路径ca ca.crtcert server111.crtkey server111.key dh dh.pem;topology subnetserver 10.8.0.0 255.255.255.0ifconfig-pool-persist /var/log/openvpn/ipp.txt;server-bridge 10.8.0.4 255.255.255.0 10.8.0.50 10.8.0.100;server-bridge;push &quot;route 192.168.10.0 255.255.255.0&quot;;push &quot;route 192.168.20.0 255.255.255.0&quot;;client-config-dir ccd;route 192.168.40.128 255.255.255.248;client-config-dir ccd;route 10.9.0.0 255.255.255.252;learn-address ./script;push &quot;redirect-gateway def1 bypass-dhcp&quot;;push &quot;dhcp-option DNS 208.67.222.222&quot;;push &quot;dhcp-option DNS 208.67.220.220&quot;;client-to-client# 不允许多用户使用同一客户端证书;duplicate-cnkeepalive 10 120# 如果执行openvpn开启命令时所在的路径就是ta.key的所在路径，只写文件名即可，否则需要写绝对路径tls-auth ta.key 0 cipher AES-256-CBC;compress lz4-v2;push &quot;compress lz4-v2&quot;;comp-lzo;max-clients 100;user nobody;group nogrouppersist-keypersist-tunstatus /var/log/openvpn/openvpn-status.log;log /var/log/openvpn/openvpn.loglog-append /var/log/openvpn/openvpn.logverb 3;explicit-exit-notify 1 3、PC-vpn客户端配置a、安装open vpn12345# linuxapt install -y openvpn# windowshttps://openvpn.net/community-downloads/ b、从服务端下载客户端所需证书文件12345678# 需要下列文件ca.crtta.keyclient1.crtclient1.key# linux复制到/etc/openvpn/下# windows复制到\\openvpn\\config\\下 c、创建客户端配置文件1234567# linux中，在/etc/openvpn/下创建client1.ovpncd /etc/openvpn/vim client1.ovpn# windows中，在\\openvpn\\config\\下创建client1.ovpn# 配置文件内容如下，根据注释内容按实际情况修改 12345678910111213141516171819202122clientdev tunproto tcp# 花生壳内网穿透映射配置后提供的公网域名和端口remote 47xxxx.fun 47557resolv-retry infinitenobindpersist-keypersist-tun# 最好写绝对路径ca ca.crtcert client1.crtkey client1.keytls-auth ta.key 1key-direction 1verb 5 4、开启树莓派vpn服务端123456# 进入server.conf所在目录下# 开启服务端openvpn --config server.conf &amp;# 打开日志显示，显示“Initialization Sequence Completed”即正常tail -f /var/log/openvpn/openvpn.log 1服务端开启后，可查看vpn局域网ip，为10.8.0.1（可在server.conf修改） 5、开启PC vpn客户端a、Linux系统下开启123# 进入client1.ovpn所在目录下# 开启客户端openvpn --config client.ovpn 1成功开启并连接到服务端后，可查看vpn局域网IP b、Windows系统下开启123打开openvpn后，在任务栏中找到openvpn图标，右键选择“选项”，打开如下界面，并选择“高级”在“配置文件”处选择存放客户端相关文件的文件夹路径，点击确定 1再次双击任务栏中openvpn图标，开始连接服务端，图标中电脑屏幕变绿即连接成功 1可查看vpn局域网ip 6、vpn虚拟局域网连通性测试12在PC中ping 10.8.0.1，测试PC与树莓派间的vpn网络是否互通如果互通，即可使用10.8.0.1这是ip来访问树莓派中应用（SSH、I-CON PLC RTE等） 7、自动化配置a、树莓派开机自启phddns12# 设置开机自启，树莓派开机后自动登录phddns客户端，连接花生壳服务器phddns enable 1# 可在花生壳管理平台“设备列表”中，查看设备登录情况 b、树莓派开机自动拨号、邮件上报IP、开启VPN服务端1234# 树莓派开机接入运营商网络后，运营商会为树莓派动态分配IP，导致使用花生壳建立的内网穿透映射失效# 使用下面的shell脚本和python程序，实现树莓派开机自动拨号上网，并将获取到的IP通过邮件形式自动上报，最后开启VPN服务端# shell脚本：auto_email_ip.sh# python程序：email_ip.py 1234567#!/bin/bashexport PATH=&#x27;/home/pi/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/local/games:/usr/games:/snap/bin&#x27;# ethx是接入运营商网络使用的网卡echo root | sudo -s udhcpc -i ethxwhile true; do (echo `ip a show ethx |egrep &#x27;\\&lt;([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-9][0-9])\\.([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-9][0-9])\\.([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-9][0-9])\\.([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-9][0-9])\\&gt;&#x27; | awk &#x27;&#123;print $2&#125;&#x27;`)&amp;&amp; break;sleep 1;done;# python程序路径python3 /root/code/email_ip/email_ip.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# 此程序可以使用一个邮箱账户自己给自己发邮件，也就是说my_sender和my_user使用一个邮箱即可# coding=utf-8import smtplibfrom email.mime.text import MIMETextfrom email.utils import formataddrimport osimport time# RTCQDBHTITKEQAGN#发送内容tdef mail(t): ret=True try: msg=MIMEText(t,&#x27;plain&#x27;,&#x27;utf-8&#x27;) msg[&#x27;From&#x27;]=formataddr([&quot;PI&quot;,my_sender]) # 括号里的对应发件人邮箱昵称、发件人邮箱账号 msg[&#x27;To&#x27;]=formataddr([&quot;Admin&quot;,my_user]) # 括号里的对应收件人邮箱昵称、收件人邮箱账号 msg[&#x27;Subject&#x27;]=&quot;树莓派IP地址上报&quot; # 邮件的主题，也可以说是标题 server=smtplib.SMTP(&quot;smtp.163.com&quot;, 25) # 发件人邮箱中的SMTP服务器，端口是25 server.login(my_sender, my_pass) # 括号中对应的是发件人邮箱账号、邮箱密码 server.sendmail(my_sender,[my_user,],msg.as_string()) # 括号中对应的是发件人邮箱账号、收件人邮箱账号、发送邮件 server.quit() # 关闭连接 except Exception: # 如果 try 中的语句没有执行，则会执行下面的 ret=False ret=False return retcmd=&#x27;ip a show ethx |egrep \\&#x27;\\\\&lt;([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-9][0-9])\\\\.([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-9][0-9])\\\\.([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-9][0-9])\\\\.([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-9][0-9])\\\\&gt;\\&#x27; | awk \\&#x27;&#123;print $2&#125;\\&#x27;&#x27;t = &quot;empty&quot;while t == &quot;empty&quot;: with os.popen(cmd,&quot;r&quot;) as p: t = p.read() if not t: t = &quot;empty&quot; time.sleep(5)# 设置发件人和收件人信息my_sender=&#x27;xxx@163.com&#x27; # 自己的邮箱账号my_pass = &#x27;&#x27; # 发件人邮箱授权码my_user=my_sender # 自己的邮箱账号ret=mail(t)if ret: print(&quot;发送邮件成功&quot;)else: print(&quot;发送邮件失败&quot;) 1234# 设置开机自动运行shell脚本crontab -e# 在配置文件最后一行添加 @reboot /root/code/email_ip/reportIp.sh 12完成上述配置后，树莓派开机后会自动接入运营商网络，获取到IP后自动发邮件上报，并自动开启vpn服务用户只需要在花生壳管理平台中修改内网穿透映射配置中的内网IP，然后启动vpn客户端即可","categories":[{"name":"open vpn","slug":"open-vpn","permalink":"http://zhongriqian.github.io/categories/open-vpn/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://zhongriqian.github.io/tags/Linux/"},{"name":"vpn","slug":"vpn","permalink":"http://zhongriqian.github.io/tags/vpn/"},{"name":"NAT traversal","slug":"NAT-traversal","permalink":"http://zhongriqian.github.io/tags/NAT-traversal/"}]},{"title":"open vpn多客户端连接服务端配置","slug":"open_vpn多客户端连接服务端配置","date":"2023-11-16T16:00:00.000Z","updated":"2023-11-21T02:42:34.971Z","comments":true,"path":"2023/11/17/open_vpn多客户端连接服务端配置/","link":"","permalink":"http://zhongriqian.github.io/2023/11/17/open_vpn%E5%A4%9A%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%85%8D%E7%BD%AE/","excerpt":"","text":"前言本文提供多vpn客户端连接到公网vpn服务端的配置流程，从而建立位于不同局域网的客户端设备之间的网络连接。 服务端配置服务端通常基于linux系统搭建，但不管是服务端还是客户端，都是通过openvpn来开启，只不过使用的配置文件不同 本教程中，服务端基于linux系统搭建，两个客户端分别基于linux和windows搭建，在下方链接中也提供windows配置openvpn服务端流程 12# windows配置openvpn服务端https://blog.eyyyye.com/article/39 安装openvpn1apt install -y openvpn 安装证书生成工具easy-rsa1apt install -y openvpn 制作证书CA证书123456789101112131415# 进入openvpn文件夹cd /etc/openvpn/# 将easy-rsa文件夹复制到openvpn文件家下cp -r /usr/share/easy-rsa/ /etc/openvpn/# 进入/etc/openvpn/easy-rsa/目录下cd /etc/openvpn/easy-rsa/# 初始化目录./easyrsa init-pki# 创建根证书，添加“nopss”参数表示不加密# 遇到“Common Name (eg: your user, host, or server name) [Easy-RSA CA]:”回车即可./easyrsa build-ca nopass Server端证书12345# 创建服务端证书，server111是自定义的服务端名称，中间遇到“Common Name (eg: your user, host, or server name) [server111]:”回车即可./easyrsa gen-req server111 nopass# 给服务端证书签名，中间遇到“ Confirm request details:”输入yes即可./easyrsa sign-req server server111 12# 使用build-server-full参数可直接完成上述创建证书和签名两个步骤./easyrsa build-server-full server111 nopass Client端-1证书12345# 创建客户端证书，client1为自定义的客户端名称，执行过程中间回车即可./easyrsa gen-req client1 nopass# 给客户端证书签名，中间遇到“ Confirm request details:”输入yes即可./easyrsa sign-req client client1 12# 使用build-client-full参数可直接完成上述创建证书和签名两个步骤./easyrsa build-client-full client1 nopass Client端-2证书12345# 创建客户端证书，client2为自定义的客户端名称，中间回车即可./easyrsa gen-req client2 nopass# 给客户端证书签名，中间遇到“ Confirm request details:”输入yes即可./easyrsa sign-req client client2 12# 使用build-client-full参数可直接完成上述创建证书和签名两个步骤./easyrsa build-client-full client2 nopass 创建Diffie-Hellman1./easyrsa gen-dh 创建TLS认证密钥1openvpn --genkey --secret ta.key 整理所有证书到指定文件夹12345678910111213141516mkdir /etc/openvpn/keyscp /etc/openvpn/easy-rsa/ta.key /etc/openvpn/keys/cp /etc/openvpn/easy-rsa/pki/ca.crt /etc/openvpn/keyscp /etc/openvpn/easy-rsa/pki/dh.pem /etc/openvpn/keyscp /etc/openvpn/easy-rsa/pki/issued/server111.crt /etc/openvpn/keyscp /etc/openvpn/easy-rsa/pki/private/server111.key /etc/openvpn/keyscp /etc/openvpn/easy-rsa/pki/issued/client1.crt /etc/openvpn/keyscp /etc/openvpn/easy-rsa/pki/private/client1.key /etc/openvpn/keyscp /etc/openvpn/easy-rsa/pki/issued/client2.crt /etc/openvpn/keyscp /etc/openvpn/easy-rsa/pki/private/client2.key /etc/openvpn/keys 创建服务端配置文件123456789# 进入指定文件夹下，解压出server.confcd /usr/share/doc/openvpn/examples/sample-config-filesgzip -d /usr/share/doc/openvpn/examples/sample-config-files/server.conf.gz# 复制server.conf到/etc/openvpn/keyscp /usr/share/doc/openvpn/examples/sample-config-files/server.conf /etc/openvpn/keys/# server.conf配置文件内容如下，根据注释内容按实际情况修改# &quot;;&quot;是注释符号，加&quot;;&quot;的行不会起作用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677;local a.b.c.dport 1194proto tcp;proto udp;dev tapdev tun;dev-node MyTap# 如果执行openvpn开启命令时所在的路径就是下列文件的所在路径，只写文件名即可，否则需要写绝对路径ca ca.crtcert server111.crtkey server111.key dh dh.pem;topology subnetserver 10.8.0.0 255.255.255.0ifconfig-pool-persist /var/log/openvpn/ipp.txt;server-bridge 10.8.0.4 255.255.255.0 10.8.0.50 10.8.0.100;server-bridge;push &quot;route 192.168.10.0 255.255.255.0&quot;;push &quot;route 192.168.20.0 255.255.255.0&quot;;client-config-dir ccd;route 192.168.40.128 255.255.255.248;client-config-dir ccd;route 10.9.0.0 255.255.255.252;learn-address ./script;push &quot;redirect-gateway def1 bypass-dhcp&quot;;push &quot;dhcp-option DNS 208.67.222.222&quot;;push &quot;dhcp-option DNS 208.67.220.220&quot;;client-to-client# 不允许多用户使用同一客户端证书;duplicate-cnkeepalive 10 120# 如果执行openvpn开启命令时所在的路径就是ta.key的所在路径，只写文件名即可，否则需要写绝对路径tls-auth ta.key 0 cipher AES-256-CBC;compress lz4-v2;push &quot;compress lz4-v2&quot;;comp-lzo;max-clients 100;user nobody;group nogrouppersist-keypersist-tunstatus /var/log/openvpn/openvpn-status.log;log /var/log/openvpn/openvpn.loglog-append /var/log/openvpn/openvpn.logverb 3;explicit-exit-notify 1 1234# 服务端配置流程结束后，生成许多证书文件和配置文件，在此总结说明# 经过上面的“整理所有证书到指定文件夹”步骤和“创建服务端配置文件”步骤，现在所有所需文件都集中到了“/etc/openvpn/keys”路径下其中ta.key、ca.crt、dh.pem、server111.crt、server111.key、server.conf是服务端所需文件；ta.key、ca.crt、client1.crt（client2.crt）、client1.key（client2.key）是客户端1（客户端2）所需文件，需要拷贝到客户端设备中 客户端配置1客户端linux、windows皆可 安装openvpn12# linuxapt install -y openvpn 12# windowshttps://openvpn.net/community-downloads/ 从服务端下载客户端所需证书文件1234567891011121314# 客户端1需要下列文件ca.crtta.keyclient1.crtclient1.key#客户端2需要下列文件ca.crtta.keyclient2.crtclient2.key# linux复制到/etc/openvpn/下# windows复制到\\openvpn\\config\\下 创建客户端配置文件1234567# linux中，在/etc/openvpn/下创建client1.ovpn或client2.ovpncd /etc/openvpn/vim client1.ovpn# windows中，在\\openvpn\\config\\下创建client1.ovpn或client2.ovpn# 配置文件内容如下，根据注释内容按实际情况修改 12345678910111213141516171819202122clientdev tunproto tcp# 服务端公网ipremote 192.168.31.92 1194resolv-retry infinitenobindpersist-keypersist-tun# 最好写绝对路径ca ca.crtcert client1.crtkey client1.keytls-auth ta.key 1key-direction 1verb 5 开启服务端123456# 进入server.conf所在目录下# 开启服务端openvpn --config server.conf &amp;# 打开日志显示，显示“Initialization Sequence Completed”即正常tail -f /var/log/openvpn/openvpn.log 开启客户端Linux中开启123# 进入client1.ovpn所在目录下# 开启客户端openvpn --config client.ovpn 1成功开启并连接到服务端后，可查看vpn局域网IP Windows中开启123打开openvpn后，在任务栏中找到openvpn图标，右键选择“选项”，打开如下界面，并选择“高级”在“配置文件”处选择存放客户端相关文件的文件夹路径，点击确定 1再次双击任务栏中openvpn图标，开始连接服务端，图标中电脑屏幕变绿即连接成功 1可查看vpn局域网ip 客户端路由配置1两个客户端开启后都可以ping通服务端，但客户端互相不能ping通，需要添加vpn局域网网段路由 12# linux系统中route add -net 10.8.0.0 netmask 255.255.255.0 dev tun0 123# windows系统中route add 10.8.0.0 mask 255.255.255.0 10.8.0.9# 并关闭防火墙 1之后即可互相ping通","categories":[{"name":"open vpn","slug":"open-vpn","permalink":"http://zhongriqian.github.io/categories/open-vpn/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://zhongriqian.github.io/tags/Linux/"},{"name":"vpn","slug":"vpn","permalink":"http://zhongriqian.github.io/tags/vpn/"}]},{"title":"基于VXLAN实现EtherCAT数据帧无线传输","slug":"基于VXLAN实现EtherCAT数据帧无线传输","date":"2023-05-14T16:00:00.000Z","updated":"2023-12-15T13:44:24.841Z","comments":true,"path":"2023/05/15/基于VXLAN实现EtherCAT数据帧无线传输/","link":"","permalink":"http://zhongriqian.github.io/2023/05/15/%E5%9F%BA%E4%BA%8EVXLAN%E5%AE%9E%E7%8E%B0EtherCAT%E6%95%B0%E6%8D%AE%E5%B8%A7%E6%97%A0%E7%BA%BF%E4%BC%A0%E8%BE%93/","excerpt":"","text":"问题描述目前EtherCAT主站、从站间的通信方式为：通过网线直连后使用层二的EtherCAT数据帧通信。但在云化PLC工控场景中，伴随PLC上云，EtherCAT主站也需要在云端部署，云端与本地使用移动无线网络通信，如5G、WiFi。在这种情况下，层二的EtherCAT数据帧如何在层三网络传输成为问题。 解决方案使用VxLAN隧道技术，直接在EtherCAT主站与从站间建立层二虚拟隧道，传输EtherCAT数据帧。 本文以Wi-Fi网络为例，设备A代表部署EtherCAT主站的设备，设备B代表从站侧前置设备，方案架构图如下。 实施步骤设备A代表部署EtherCAT主站的设备，设备B代表从站侧前置设备 设备A配置创建虚拟网络设备创建veth，将其配置为EtherCAT主站网卡设备。在后续需要加入虚拟网桥中，这样veth0发出的EtherCAT数据帧会由虚拟网桥发送给VxLAN隧道端点进行封装。 123456// 创建ip link add veth0 type veth ip link add veth0 type veth peer name veth1// 开启接口，一般默认开启，但保险起见还是用命令开启一下ip link set dev veth0 up 配置EtherCAT网卡12// 使用vim打开ethercat配置文件vim $ethercat-path/etc/sysconfig/ethercat 12// 找到下方内容，将双引号内改为veth0的MAC地址MASTER0_DEVICE=&quot;&quot; 创建vetpVTEP（VXLAN Tunnel Endpoints）是VXLAN隧道的端点，在两个设备上都要创建。vetp（vxlan0）后续要与veth0加入到同一虚拟网桥中，这样veth0发出的EtherCAT帧会由vxlan0接收，由vxlan0对EtherCAT数据帧封装上vxlan头后再封装udp头，使其成为层三数据帧，最后由设备A上实际的网卡（wlan0）发送出去。相应的其接收到上行的数据帧后也会从中解封装出EtherCAT数据帧，再发送给veth0。 1234567// remote后指定对端设备用于接收vxlan帧的网卡的IP，dev后指定本设备用于发送vxlan帧的网卡名// id指定vxlan隧道ID，在设备B上创建时要指定为相同的ID// dstport为封装vxlan帧的UDP头中的端口号ip link add vxlan0 type vxlan id 42 dstport 4789 remote 192.168.31.20 dev wlan0// 开启vxlan0ip link set vxlan0 up 创建虚拟网桥创建虚拟网桥br0，并将veth1和vxlan0加入其中，使两者能互相收发EtherCAT数据帧。 123456789// 创建虚拟网桥br0brctl addbr br0// 将vxlan0和veth1加入br0brctl addif br0 vxlan0brctl addif br0 veth0// 开启br0ifconfig br0 up 设备B配置创建vxlan创建设备B上的VXLAN隧道的端点。 1234ip link add vxlan0 type vxlan id 42 dstport 4789 remote 192.168.31.10 dev wlan0// 开启vxlan0ip link set vxlan0 up 创建虚拟网桥将vxlan0和设备B连接EtherCAT从站的网口加入虚拟网桥br0。 123456789// 创建虚拟网桥br0brctl addbr br0// 将vxlan0和eth0加入br0brctl addif br0 vxlan0brctl addif br0 eth0// 开启br0ifconfig br0 up 到此，EtherCAT主站与从站间的vxlan通道建立完成，EtherCAT主站并不会察觉底层网络的改变，使用和之前无异。但EtherCAT主从间的通信会受网络性能影响，在使用网线时能正常工作，但使用Wi-Fi时系统稳定性较差。 其他命令1234567891011121314151617181920212223// 查看vxlanip -d link show dev vxlan名称ip -d link show dev vxlan0// 删除vxlanip link delete vxlan名称ip link delete vxlan0// 查看虚拟网桥brctl showbrctl show 网桥名称// 从虚拟网桥中删除网卡brctl delif 网桥名称 网卡名称brctl delif br0 eth0// 删除虚拟网桥brctl delbr 网桥名称brctl delbr br0// 删除vethip link delete veth0// 删除一端后另一端自动删除","categories":[{"name":"EtherCAT","slug":"EtherCAT","permalink":"http://zhongriqian.github.io/categories/EtherCAT/"}],"tags":[{"name":"EtherCAT","slug":"EtherCAT","permalink":"http://zhongriqian.github.io/tags/EtherCAT/"},{"name":"Linux","slug":"Linux","permalink":"http://zhongriqian.github.io/tags/Linux/"},{"name":"VxLAN","slug":"VxLAN","permalink":"http://zhongriqian.github.io/tags/VxLAN/"}]},{"title":"进程间通信(IPC)","slug":"进程间通信","date":"2023-05-11T16:00:00.000Z","updated":"2023-05-14T04:17:41.735Z","comments":true,"path":"2023/05/12/进程间通信/","link":"","permalink":"http://zhongriqian.github.io/2023/05/12/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/","excerpt":"","text":"共享内存特性 性能最快 物理内存中开辟共享内存，进程在页表中将共享内存与地址空间形成映射 共享内存没有访问控制，不提供同步或互斥机制 共享内存生命周期不跟随进程，进程结束后共享内存不会自动释放，需要在进程中使用接口函数将共享内存释放，或使用命令行释放 编程实现步骤 A进程创建共享内存并将共享内存映射到进程地址空间 B进程获取共享内存并将共享内存映射到进程地址空间 A、B进程通过共享内存交互数据 A、B进程删除映射 A进程释放共享内存 数据结构shmid_ds123456789101112131415// 描述共享内存struct shmid_ds &#123; struct ipc_perm shm_perm; /* operation perms */ int shm_segsz; /* size of segment (bytes) *///共享内存空间大小 __kernel_time_t shm_atime; /* last attach time *///挂接时间 __kernel_time_t shm_dtime; /* last detach time *///取消挂接时间 __kernel_time_t shm_ctime; /* last change time *///改变时间 __kernel_ipc_pid_t shm_cpid; /* pid of creator */ __kernel_ipc_pid_t shm_lpid; /* pid of last operator */ unsigned short shm_nattch; /* no. of current attaches *///进程挂接数 unsigned short shm_unused; /* compatibility */ void* shm_unused2; /* ditto - used by DIPC */ void* shm_unused3; /* unused */&#125;; ipc_perm1234567891011// IPC关键信息struct ipc_perm&#123; __kernel_key_t key; //共享内存的唯一标识符 __kernel_uid_t uid; __kernel_gid_t gid; __kernel_uid_t cuid; __kernel_gid_t cgid; __kernel_mode_t mode; //权限 unsigned short seq;&#125;; 函数ftok12345678910// 获取唯一key#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;key_t ftok(const char *pathname, // 真实文件路径 int proj_id // 非零值 );// 返回key值 shmget123456789101112// 创建共享内存#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;int shmget(key_t key, // key值，可以用ftok获取，也可以自己任意指定一个 size_t size, // 共享内存大小，一般申请4096byte的整数倍，即使不申请整数倍，系统也会凑整分配 int shmflg // 共享内存属性，一般设置为：IPC_CREAT | IPC_EXCL | 0666 );// 成功返回共享内存ID，失败返回-1// key值和共享内存ID都唯一对应一段共享内存，但key值是内核级的，供内核标识；共享内存ID是用户级的，供用户使用 shmctl1234567891011// 控制共享内存，一般用于释放共享内存#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;int shmctl(int shmid, // 共享内存ID int cmd, // 控制指令，释放共享内存指令为IPC_RMID struct shmid_ds *buf // 释放时使用空指针即可，nullptr ); // 成功返回0， 失败返回-1 shmat1234567891011// 将共享内存映射到调用该函数的进程地址空间#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;void *shmat(int shmid, // 共享内存ID const void *shmaddr, // 指定共享内存连接到进程地址空间的地址，设置为null则默认让系统指定 int shmflg // 权限，SHM_RDONLY(只读)，SHM_REMAP(重映射到一个进程地址空间地址)，0(系统默认) ); // 返回映射到进程地址空间共享区起始地址 shmdt123456// 删除共享内存与进程地址空间的映射关系，释放进程地址空间int shmdt(const void *shmaddr // 共享内存映射到进程地址空间的地址 ); // 成功返回0，失败返回-1 操作命令查看共享内存1ipcs -m 释放共享内存1ipcrm -m shmid 示例程序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// A.c#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define SHM_PATH &quot;/tmp&quot; // 共享内存所在的文件路径int main()&#123; key_t key1 = ftok(SHM_PATH, &#x27;A&#x27;); printf(&quot;key1 : %d\\n&quot;, key1); int shmid1 = shmget(key1, 4096, IPC_CREAT | IPC_EXCL | 0666); printf(&quot;shmid1 : %d\\n&quot;, shmid1); key_t key2 = ftok(SHM_PATH, &#x27;B&#x27;); printf(&quot;key2 : %d\\n&quot;, key2); int shmid2 = shmget(key2, 4096, IPC_CREAT | IPC_EXCL | 0666); printf(&quot;shmid2 : %d\\n&quot;, shmid2); /*******************************************************************/ // 将共享内存附加到进程地址空间 int* a = (int *) shmat(shmid1, NULL, 0); //int* b = (int *) shmat(shmid1, NULL, 0); // 多变量需要用数组指针方式存储 int* b = (int *) shmat(shmid2, NULL, 0); // 在共享内存中创建变量 *a = 10; *(a+1) = 20; *b = 100; *(b+1) = 200; // 输出共享内存中变量的地址和值 printf(&quot;a的地址： %p\\n&quot;, a); printf(&quot;a的值： %d\\n&quot;, *a); printf(&quot;a+1的地址： %p\\n&quot;, a+1); printf(&quot;a+1的值： %d\\n&quot;, *(a+1)); printf(&quot;b的地址： %p\\n&quot;, b); printf(&quot;b的值： %d\\n&quot;, *b); printf(&quot;b+1的地址： %p\\n&quot;, b+1); printf(&quot;b+1的值： %d\\n&quot;, *(b+1)); // 等待程序B读取变量a的值 getchar(); // 输出共享内存中变量的地址和值 printf(&quot;a的地址： %p\\n&quot;, a); printf(&quot;a的值： %d\\n&quot;, *a); printf(&quot;a+1的地址： %p\\n&quot;, a+1); printf(&quot;a+1的值： %d\\n&quot;, *(a+1)); printf(&quot;b的地址： %p\\n&quot;, b); printf(&quot;b的值： %d\\n&quot;, *b); printf(&quot;b+1的地址： %p\\n&quot;, b+1); printf(&quot;b+1的值： %d\\n&quot;, *(b+1)); // 将共享内存从进程地址空间中分离 shmdt(a); shmdt(b); // 删除共享内存 shmctl(shmid1, IPC_RMID, NULL); shmctl(shmid2, IPC_RMID, NULL); return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// B.c#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define SHM_PATH &quot;/tmp&quot; // 共享内存所在的文件路径int main()&#123; key_t key1 = ftok(SHM_PATH, &#x27;A&#x27;); printf(&quot;key1 : %d\\n&quot;, key1); int shmid1 = shmget(key1, 4096, 0); printf(&quot;shmid1 : %d\\n&quot;, shmid1); key_t key2 = ftok(SHM_PATH, &#x27;B&#x27;); printf(&quot;key2 : %d\\n&quot;, key2); int shmid2 = shmget(key2, 4096, 0); printf(&quot;shmid2 : %d\\n&quot;, shmid2); /*******************************************************************/ // 将共享内存附加到进程地址空间 int* a = (int *) shmat(shmid1, NULL, 0); int* b = (int *) shmat(shmid2, NULL, 0); // 输出共享内存中变量的地址和值 printf(&quot;a的地址： %p\\n&quot;, a); printf(&quot;a的值： %d\\n&quot;, *a); printf(&quot;a+1的地址： %p\\n&quot;, a+1); printf(&quot;a+1的值： %d\\n&quot;, *(a+1)); printf(&quot;b的地址： %p\\n&quot;, b); printf(&quot;b的值： %d\\n&quot;, *b); printf(&quot;b+1的地址： %p\\n&quot;, b+1); printf(&quot;b+1的值： %d\\n&quot;, *(b+1)); // 在共享内存中创建变量a *a = 1; *(a+1) = 2; *b = 11; *(b+1) = 22; // 输出共享内存中变量的地址和值 printf(&quot;a的地址： %p\\n&quot;, a); printf(&quot;a的值： %d\\n&quot;, *a); printf(&quot;a+1的地址： %p\\n&quot;, a+1); printf(&quot;a+1的值： %d\\n&quot;, *(a+1)); printf(&quot;b的地址： %p\\n&quot;, b); printf(&quot;b的值： %d\\n&quot;, *b); printf(&quot;b+1的地址： %p\\n&quot;, b+1); printf(&quot;b+1的值： %d\\n&quot;, *(b+1)); // 将共享内存从进程地址空间中分离 shmdt(a); //shmdt(b); return 0;&#125; 匿名管道特性 用于连接一个读进程和一个写进程以实现两者之间通信的一个“共享文件” 仅适用于具有亲缘关系的进程间通信，匿名管道无法被其他进程找到 半双工，需要全双工通信时可以创建两个管道 管道的生命周期跟随进程，进程结束后管道会释放 每个进程都持有一对管道的读端、写端，不同进程间的读端、写端不会互相影响 读写规则 管道所有写端都关闭情况下，当有进程从管道读端读取时，管道剩余数据读取完后，继续读取会返回0 管道写端没关闭，但也没进程向管道写端写入的情况下，当有进程从管道读端读取时，管道剩余数据读取完后，读端进程会阻塞 管道所有读端都关闭情况下，当有进程向管道写端写入时，进程会收到信号SIGPIPE，导致进程异常终止 管道读端没关闭，但也没进程从管道读端读取的情况下，当有进程向管道写端写入时，管道剩余容量写满后，写端进程会阻塞 编程实现步骤 父进程创建并打开匿名管道 父进程创建子进程 管道读写 父进程对管道的读端、写端进行操作 子进程对管道的读端、写端进行操作 函数pipe12345678// 创建并打开匿名管道#include &lt;unistd.h&gt;int pipe(int fd[2] // 文件描述符，fd[0]表示读端，fd[1]表示写端 ); // 成功返回0， 失败返回错误代码 fork12345678910// 父进程创建子进程#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;pid_t fork();// 父进程返回新创建子进程的进程ID// 子进程返回0// 失败返回负值 命名管道特性 命名管道可以实现进程间通过同一个路径名看到同一份资源，这份资源以FIFO文件形式存在于文件系统中 不具备亲缘关系的进程间也可以使用 需要先创建，再打开（匿名管道创建即打开） 编程实现步骤 进程A选定路径创建命名管道 进程A根据选定的路径打开命名管道 进程B根据选定的路径打开命名管道 管道读写 进程A对管道读端、写端操作 进程B对管道读端、写端操作 函数mkfifo12345678910// 创建命名管道#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;int mkfifo(const char* pathname, // 文件路径 mode_t mode // 文件权限 ); // 成功返回0，失败返回-1 open123456789101112131415// 打开命名管道#include&lt;fcntl.h&gt;#include&lt;unistd.h&gt;int open(const char* pathname, // 文件路径 int flags // 打开模式，O_RDONLY(只读)，O_WRONLY(只写)，O_RDWR(可读可写) ); int open(const char* pathname, // 文件路径 int flags, // 打开模式，O_CREAT(创建) mode_t mode // 文件权限 ); // 成功返回文件描述符fd，失败返回-1 close123456789// 关闭命名通道#include&lt;fcntl.h&gt;#include&lt;unistd.h&gt;int close(int fd // 文件描述符 );// 成功返回0，失败返回-1 read12345678910// 从管道（文件）读取内容#include &lt;unistd.h&gt;ssize_t read(int fd, // 文件描述符 void *buf, // 指向接收数据缓冲区的指针 size_t count // 读取字节数 ); // 成功返回实际读取的字节数，失败返回-1 wirte12345678910// 向管道（文件）写入内容#include &lt;unistd.h&gt;ssize_t write(int fd, // 文件描述符 const void * buf, // 指向写入数据缓冲区的指针 size_t count // 写入字节数 ); // 成功返回实际写入的字节数，失败返回-1 操作命令创建命名管道123mkfifo pathnamemkfifo /tmp/test 查看命名管道123ls -lF pathnamels -lF /tmp/test 向命名管道写入1234echo &quot;xxx&quot; &gt; pathnamels / &gt; pathnameecho &quot;Helloworld&quot; &gt; /tmp/test 从命名管道读取123cat &lt; pathnamecat &lt; /tmp/test 删除命名管道123rm pathnamerm /tmp/test 消息队列特性 系统内核中的一个链表 发送进程将消息添加到消息队列末尾，接收进程从消息队列头部读取消息 多个进程可以同时向一个消息队列发送，也可以同时从一个消息队列中接收 通过结构体对信息打包 可以在结构体中自定义消息的规格细节，其中消息类型和消息内容是必须定义的 保证以消息为单位接收 能根据消息结构体中定义的消息类型接收消息 编程实现步骤 A进程创建消息队列 B进程获取消息队列 数据交互 任意进程关闭消息队列 数据结构msgbuf123456#include &lt;sys/msg.h&gt;struct msgbuf &#123; long mtype; /* 消息的类型，必须为正数 */ char mtext[1]; /* 消息正文 */ &#125;; msg 12345678#include &lt;sys/msg.h&gt;struct msg &#123; struct msg *msg_next; /* 消息队列的下一条消息 */ long msg_type; /*消息类型*/ char *msg_spot; /* 消息正文的地址 */ short msg_ts; /* 消息正文的大小 */ &#125;; msqid_ds123456789101112131415#include &lt;sys/msg.h&gt;struct msqid_ds &#123; struct ipc_perm msg_perm; /* 消息的权限 */ struct msg *msg_first; /* 队列上第一条消息，即链表头 */ struct msg *msg_last; /* 队列中的最后一条消息，即链表尾 */ time_t msg_stime; /* 发送给队列的最后一条消息的时间 */ time_t msg_rtime; /* 从消息队列接收到的最后一条消息的时间 */ time_t msg_ctime; /* 最后修改队列的时间*/ ushort msg_cbytes; /* 队列上所有消息总的字节数 */ ushort msg_qnum; /* 在当前队列上消息的个数 */ ushort msg_qbytes; /* 队列最大的字节数 */ ushort msg_lspid; /* 发送最后一条消息的进程的pid */ ushort msg_lrpid; /* 接收最后一条消息的进程的pid */&#125;; 函数msgget1234567891011// 创建消息队列#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;int msgget(key_t key, // key值 int msgflg // 消息队列属性 ); // 成功返回消息队列ID，失败返回-1 msgctl123456789101112// 控制（删除）消息队列#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;int msgctl(int msqid, // 消息队列ID int cmd, // 控制命令，IPC_RMID(删除)， struct msqid_ds *buf // 控制命令为删除时，设为NULL ); // 成功返回0，失败返回-1 msgsend12345678910111213// 向消息队列发送消息#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;int msgsnd(int msqid, // 消息队列ID const void *msgp, // 指向待发送消息缓冲区的指针 size_t msgsz, // 除去消息类型(mtype)的消息字节数 int msgflg // 0：阻塞；IPC_NOWAIT:不阻塞 );// 成功返回0，失败返回-1 msgrcv12345678910111213141516171819// 从消息队列接收消息#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;ssize_t msgrcv(int msqid, // 消息队列ID void *msgp, // 指存放消息缓冲区的指针 size_t msgsz, // 除去消息类型(mtype)的消息字节数 long msgtyp, // 消息类型 // 0：获取队列中第一条消息 // &gt;0：获取类型为 msgtyp 的第一条消息 // &lt;0：按优先级队列最小获取类型≤|msgtyp|的第一条消息 int msgflg // 0：阻塞；IPC_NOWAIT:不阻塞； // MSG_EXCEPT：仅用于msgtyp&gt;0的情况，表示获取类型不为msgtyp的消息 // MSG_NOERROR：如果消息数据正文内容大于msgsz，就将消息数据截断为msgsz );// 成功返回接受的消息字节数，失败返回-1 操作命令查看消息队列1ipcs -q 查看消息队列对应的用户、发送和接收进程pid1ipcs -pq 查看该msgid的消息队列的详细情况1ipcs -q -i msgid 删除消息队列1ipcrm -Q key 示例程序12345678910111213141516171819202122232425262728293031323334353637// msgsend.c#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#include &lt;stdlib.h&gt;struct msgbuf &#123; long mtype; /* message type, must be &gt; 0 */ char mtext[256]; /* message data */&#125;;int main()&#123; key_t key = ftok(&quot;.&quot;,&#x27;o&#x27;); printf(&quot;key = %x\\n&quot;,key); int msgid = msgget(key, IPC_CREAT | IPC_EXCL | 0666); if(msgid == -1)&#123; printf(&quot;create queue failed!\\n&quot;); exit(1); &#125; struct msgbuf buf1 = &#123;1,&quot;buf1&quot;&#125;; struct msgbuf buf2 = &#123;2,&quot;buf2&quot;&#125;; struct msgbuf buf3 = &#123;3,&quot;buf3&quot;&#125;; struct msgbuf buf4 = &#123;1,&quot;buf4&quot;&#125;; msgsnd(msgid,&amp;buf1,sizeof(buf1.mtext),0); msgsnd(msgid,&amp;buf2,sizeof(buf2.mtext),0); msgsnd(msgid,&amp;buf3,sizeof(buf3.mtext),0); msgsnd(msgid,&amp;buf4,sizeof(buf4.mtext),0); //msgctl(msgid,IPC_RMID,NULL); return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344// msgrcv.c#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/msg.h&gt;#include &lt;stdlib.h&gt;struct msgbuf &#123; long mtype; /* message type, must be &gt; 0 */ char mtext[256]; /* message data */&#125;;int main()&#123; key_t key = ftok(&quot;.&quot;,&#x27;o&#x27;); printf(&quot;key = %x\\n&quot;,key); int msgid = msgget(key, 0); if(msgid == -1)&#123; printf(&quot;create queue failed!\\n&quot;); exit(1); &#125; struct msgbuf getbuf; msgrcv(msgid,&amp;getbuf,sizeof(getbuf.mtext),2,0); printf(&quot;Received send message:%s\\n&quot;,getbuf.mtext); memset(getbuf.mtext, &#x27;\\0&#x27;, sizeof(getbuf.mtext)); msgrcv(msgid,&amp;getbuf,sizeof(getbuf.mtext),3,0); printf(&quot;Received send message:%s\\n&quot;,getbuf.mtext); memset(getbuf.mtext, &#x27;\\0&#x27;, sizeof(getbuf.mtext)); msgrcv(msgid,&amp;getbuf,sizeof(getbuf.mtext),1,0); printf(&quot;Received send message:%s\\n&quot;,getbuf.mtext); memset(getbuf.mtext, &#x27;\\0&#x27;, sizeof(getbuf.mtext)); msgrcv(msgid,&amp;getbuf,sizeof(getbuf.mtext),1,0); printf(&quot;Received send message:%s\\n&quot;,getbuf.mtext); msgctl(msgid,IPC_RMID,NULL); return 0;&#125;","categories":[{"name":"Linux","slug":"Linux","permalink":"http://zhongriqian.github.io/categories/Linux/"}],"tags":[{"name":"C","slug":"C","permalink":"http://zhongriqian.github.io/tags/C/"},{"name":"Linux","slug":"Linux","permalink":"http://zhongriqian.github.io/tags/Linux/"}]},{"title":"IGH接口函数","slug":"IGH接口函数","date":"2023-03-07T16:00:00.000Z","updated":"2023-03-08T03:25:51.484Z","comments":true,"path":"2023/03/08/IGH接口函数/","link":"","permalink":"http://zhongriqian.github.io/2023/03/08/IGH%E6%8E%A5%E5%8F%A3%E5%87%BD%E6%95%B0/","excerpt":"","text":"ecrt_master_application_time123456789void ecrt_master_application_time(ec_master_t *master, uint64_t app_time)&#123; master-&gt;app_time = app_time; if (unlikely(!master-&gt;has_app_time)) &#123; master-&gt;app_start_time = app_time; master-&gt;has_app_time = 1; &#125;&#125; ecrt_master_reference_clock_time12345678910111213141516int ecrt_master_reference_clock_time(ec_master_t *master, uint32_t *time)&#123; if (!master-&gt;dc_ref_clock) &#123; return -ENXIO; &#125; if (master-&gt;sync_datagram.state != EC_DATAGRAM_RECEIVED) &#123; return -EIO; &#125; // Get returned datagram time, transmission delay removed. *time = EC_READ_U32(master-&gt;sync_datagram.data) - master-&gt;dc_ref_clock-&gt;transmission_delay; return 0;&#125; ecrt_master_sync_reference_clock1234567void ecrt_master_sync_reference_clock(ec_master_t *master)&#123; if (master-&gt;dc_ref_clock) &#123; EC_WRITE_U32(master-&gt;ref_sync_datagram.data, master-&gt;app_time); ec_master_queue_datagram(master, &amp;master-&gt;ref_sync_datagram); &#125;&#125; ecrt_master_sync_slave_clocks1234567void ecrt_master_sync_slave_clocks(ec_master_t *master)&#123; if (master-&gt;dc_ref_clock) &#123; ec_datagram_zero(&amp;master-&gt;sync_datagram); ec_master_queue_datagram(master, &amp;master-&gt;sync_datagram); &#125;&#125;","categories":[],"tags":[]},{"title":"IGH_DC同步程序设计方案及接口函数介绍","slug":"IGH-DC同步程序设计方案及接口函数介绍","date":"2023-02-26T16:00:00.000Z","updated":"2024-01-07T09:02:25.245Z","comments":true,"path":"2023/02/27/IGH-DC同步程序设计方案及接口函数介绍/","link":"","permalink":"http://zhongriqian.github.io/2023/02/27/IGH-DC%E5%90%8C%E6%AD%A5%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88%E5%8F%8A%E6%8E%A5%E5%8F%A3%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"设计方案从站作为参考时钟 激活从站的DC功能。 使用ecrt_slave_config_dc(ec_slave_config_t *sc, uint16_t assign_activate, uint32_t sync0_cycle, int32_t sync0_shift, uint32_t sync1_cycle, int32_t sync1_shift) 指定一个从站作为参考时钟，一般选用接入主站拓扑中的第一个带有DC功能的从站 使用ecrt_master_select_reference_clock(ec_master_t *master, ec_slave_config_t *sc) 在每个通信周期里，将主站时钟，以及其他从站时钟都同步到参考时钟 每个周期，主站首先更新本地时钟 使用ecrt_master_application_time(ec_master_t *master, uint64_t app_time) 然后主站获取参考时钟并保存在time中（注意主站时钟同步到参考时钟的程序需用户自行完成，IGH没有提供相应接口） 使用ecrt_master_reference_clock_time(ec_master_t *master, uint32_t *time) 最后将参考时钟发送给其他从站，使其他从站时钟同步到参考时钟 使用ecrt_master_sync_slave_clocks(ec_master_t *master) 主站作为参考时钟 激活从站DC功能 使用ecrt_slave_config_dc(ec_slave_config_t *sc, uint16_t assign_activate, uint32_t sync0_cycle, int32_t sync0_shift, uint32_t sync1_cycle, int32_t sync1_shift) 将第一个带DC功能的从站设置为参考时钟 使用ecrt_master_select_reference_clock(ec_master_t *master, ec_slave_config_t *sc) 每个周期里，将参考时钟的值改为主站时钟的值，并将改后的参考时钟发送给其他从站 主站首先更新本地时钟 使用ecrt_master_application_time(ec_master_t *master, uint64_t app_time) 修改参考时钟，改为主站时钟的值 使用ecrt_master_sync_reference_clock_to(ec_master_t *master, uint64_t sync_time) 或ecrt_master_sync_reference_clock(ec_master_t *master) 将参考时钟发送给其他从站，使其他从站时钟同步到参考时钟 使用ecrt_master_sync_slave_clocks(ec_master_t *master) 接口函数ecrt_slave_config_dc123456789101112131415161718192021222324252627282930313233343536373839404142/** Configure distributed clocks. * 配置分布式时钟（DC） * * Sets the AssignActivate word and the cycle and shift times for the sync * signals. * 设置激活字以及同步信号的周期和偏移时间 * * The AssignActivate word is vendor-specific and can be taken from the XML * device description file (Device -&gt; Dc -&gt; AssignActivate). Set this to zero, * if the slave shall be operated without distributed clocks (default). * 激活字是厂商指定的，可以在ESI(Device -&gt; Dc -&gt; AssignActivate)中查询。 * 激活字用于设置从站的0x0980和0x0981两个寄存器的值，这两个寄存器正是同步信号控制器相关的寄存器。 * 大多数厂商的激活字都设置为0x0300，根据两个寄存器中每一位的置位功能分析出，设置0x0300功能为激活SYNC0信号。 * （0x0500为激活SYNC1信号，0x0700为激活SYNC0和SYNC1信号） * 后四个参数用于设置SYNC0和SYNC1信号的周期和偏移时间，单位纳秒。 * * This method has to be called in non-realtime context before * ecrt_master_activate(). * * \\attention The \\a sync1_shift time is ignored. */void ecrt_slave_config_dc( ec_slave_config_t *sc, /**&lt; Slave configuration. */ uint16_t assign_activate, /**&lt; AssignActivate word. */ uint32_t sync0_cycle, /**&lt; SYNC0 cycle time [ns]. */ int32_t sync0_shift, /**&lt; SYNC0 shift time [ns]. */ uint32_t sync1_cycle, /**&lt; SYNC1 cycle time [ns]. */ int32_t sync1_shift /**&lt; SYNC1 shift time [ns]. */ )&#123; EC_CONFIG_DBG(sc, 1, &quot;%s(sc = 0x%p, assign_activate = 0x%04X,&quot; &quot; sync0_cycle = %u, sync0_shift = %i,&quot; &quot; sync1_cycle = %u, sync1_shift = %i\\n&quot;, __func__, sc, assign_activate, sync0_cycle_time, sync0_shift_time, sync1_cycle_time, sync1_shift_time); sc-&gt;dc_assign_activate = assign_activate; sc-&gt;dc_sync[0].cycle_time = sync0_cycle_time; sc-&gt;dc_sync[0].shift_time = sync0_shift_time; sc-&gt;dc_sync[1].cycle_time = sync1_cycle_time; sc-&gt;dc_sync[1].shift_time = sync1_shift_time;&#125; ecrt_master_select_reference_clock1234567891011121314151617181920212223242526272829303132333435/** Selects the reference clock for distributed clocks. * 给分布式时钟系统选择参考时钟 * * If this method is not called for a certain master, or if the slave * configuration pointer is NULL, then the first slave with DC functionality * will provide the reference clock. * 如果此方法没有被主站调用，或从站指针为NULL，则默认选择第一个具有DC功能的从站提供参考时钟 * * \\return 0 on success, otherwise negative error code. * 返回0为成功，失败则返回负数错误代码 */int ecrt_master_select_reference_clock( ec_master_t *master, /**&lt; EtherCAT master. */ ec_slave_config_t *sc /**&lt; Slave config of the slave to use as the * reference slave (or NULL). */ )&#123; master-&gt;dc_ref_config = sc; if (master-&gt;dc_ref_config) &#123; EC_MASTER_INFO(master, &quot;Application selected DC reference clock&quot; &quot; config (%u-%u) set by application.\\n&quot;, master-&gt;dc_ref_config-&gt;alias, master-&gt;dc_ref_config-&gt;position); &#125; else &#123; EC_MASTER_INFO(master, &quot;Application selected DC reference clock&quot; &quot; config cleared by application.\\n&quot;); &#125; // update dc datagrams ec_master_find_dc_ref_clock(master); return 0;&#125; ecrt_master_application_time1234567891011121314151617181920212223242526272829303132/** Sets the application time.设置应用时间 * * The master has to know the application&#x27;s time when operating slaves with * distributed clocks. The time is not incremented by the master itself, so * this method has to be called cyclically. * * * \\attention The time passed to this method is used to calculate the phase of * the slaves&#x27; SYNC0/1 interrupts. It should be called constantly at the same * point of the realtime cycle. So it is recommended to call it at the start * of the calculations to avoid deviancies due to changing execution times. * * The time is used when setting the slaves&#x27; &lt;tt&gt;System Time Offset&lt;/tt&gt; and * &lt;tt&gt;Cyclic Operation Start Time&lt;/tt&gt; registers and when synchronizing the * DC reference clock to the application time via * ecrt_master_sync_reference_clock(). * * The time is defined as nanoseconds from 2000-01-01 00:00. Converting an * epoch time can be done with the EC_TIMEVAL2NANO() macro, but is not * necessary, since the absolute value is not of any interest. */void ecrt_master_application_time( ec_master_t *master, /**&lt; EtherCAT master. */ uint64_t app_time /**&lt; Application time. */ )&#123; master-&gt;app_time = app_time; if (unlikely(!master-&gt;dc_ref_time)) &#123; master-&gt;dc_ref_time = app_time; &#125;&#125; ecrt_master_reference_clock_time1234567891011121314151617181920212223242526272829303132333435363738394041/** Get the lower 32 bit of the reference clock system time. * 获取参考时钟的低32位 * * This method can be used to synchronize the master to the reference clock. * 可以用于将主站时钟同步到参考时钟 * * The reference clock system time is queried via the * ecrt_master_sync_slave_clocks() method, that reads the system time of the * reference clock and writes it to the slave clocks (so be sure to call it * cyclically to get valid data). * * \\attention The returned time is the system time of the reference clock * minus the transmission delay of the reference clock. * * \\retval 0 success, system time was written into \\a time. * \\retval -ENXIO No reference clock found. * \\retval -EIO Slave synchronization datagram was not received. */int ecrt_master_reference_clock_time( ec_master_t *master, /**&lt; EtherCAT master. */ uint32_t *time /**&lt; Pointer to store the queried system time. */ )&#123; if (!master-&gt;dc_ref_clock) &#123; return -ENXIO; &#125; if (master-&gt;sync_datagram.state != EC_DATAGRAM_RECEIVED) &#123; return -EIO; &#125; if (!master-&gt;dc_offset_valid) &#123; return -EAGAIN; &#125; // Get returned datagram time, transmission delay removed. *time = EC_READ_U32(master-&gt;sync_datagram.data) - master-&gt;dc_ref_clock-&gt;transmission_delay; return 0;&#125; ecrt_master_sync_slave_clocks123456789101112131415/** Queues the DC clock drift compensation datagram for sending. * 将DC漂移补偿数据报排队发送 * * All slave clocks synchronized to the reference clock. * 使所有从站时钟同步到参考时钟 */void ecrt_master_sync_slave_clocks( ec_master_t *master /**&lt; EtherCAT master. */ )&#123; if (master-&gt;dc_ref_clock &amp;&amp; master-&gt;dc_offset_valid) &#123; ec_datagram_zero(&amp;master-&gt;sync_datagram); ec_master_queue_datagram(master, &amp;master-&gt;sync_datagram); &#125;&#125; ecrt_master_sync_reference_clock_to1234567891011121314151617/** Queues the DC reference clock drift compensation datagram for sending. * 将DC参考时钟漂移补偿数据报排队发送 * * The reference clock will by synchronized to the time passed in the * sync_time parameter. * 参考时钟会被同步到第二个参数的值 */void ecrt_master_sync_reference_clock_to( ec_master_t *master, /**&lt; EtherCAT master. */ uint64_t sync_time /**&lt; Sync reference clock to this time. */ )&#123; if (master-&gt;dc_ref_clock) &#123; EC_WRITE_U32(master-&gt;ref_sync_datagram.data, sync_time); ec_master_queue_datagram(master, &amp;master-&gt;ref_sync_datagram); &#125;&#125; ecrt_master_sync_reference_clock123456789101112131415/** Queues the DC reference clock drift compensation datagram for sending. * * The reference clock will by synchronized to the application time provided * by the last call off ecrt_master_application_time(). * 与上一个函数功能类似，区别是不需要指定时间值，自动选择ecrt_master_application_time()获取的值。 */void ecrt_master_sync_reference_clock( ec_master_t *master /**&lt; EtherCAT master. */ )&#123; if (master-&gt;dc_ref_clock &amp;&amp; master-&gt;dc_offset_valid) &#123; EC_WRITE_U32(master-&gt;ref_sync_datagram.data, master-&gt;app_time); ec_master_queue_datagram(master, &amp;master-&gt;ref_sync_datagram); &#125;&#125; 程序示例 从站：两个LAN9252 EtherCAT开发板 功能：流水灯 同步精度：从站作为参考时钟，同步精度达到20ns左右，收敛时间约为3分钟 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434#include &lt;errno.h&gt;#include &lt;signal.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/resource.h&gt;#include &lt;sys/time.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;time.h&gt;#include &lt;sys/mman.h&gt;#include &lt;malloc.h&gt;#include &quot;ecrt.h&quot;/*****************************************************************************/// ethercatstatic ec_master_t *master = NULL;static ec_domain_t *domain1 = NULL;static ec_slave_config_t *slave0 = NULL;static ec_slave_config_t *slave1 = NULL;/*****************************************************************************/// application parameters//#define CLOCK_TO_USE CLOCK_MONOTONIC #define CLOCK_TO_USE CLOCK_REALTIME#define cycle_t 10000000 /*本次设置周期PERIOD_NS为10ms*/#define NSEC_PER_SEC (1000000000L) #define TIMESPEC2NS(T) ((uint64_t) (T).tv_sec * NSEC_PER_SEC + (T).tv_nsec)#define SLAVE_REF 1 // 选择从站作为参考时钟：1 选择主站作为参考时钟：0const struct timespec cycletime = &#123;0, cycle_t&#125;;struct timespec wakeupTime; // 唤醒时间struct timespec sync_time; // 用于将主站时间写入从站 int cycle_times = 0; // 循环次数int LED[8] = &#123;1,1,1,1,1,1,1,1&#125;;int led = 0;uint32_t diff_time_ns; // 最大时钟偏移值，单位nsstruct timeval start,end; // 用于记录程序运行时间 FILE *fp = NULL; // 输出数据到csv文件/*****************************************************************************/// process data#define PANASONIC_0 0,0 /*EtherCAT address on the bus*/#define PANASONIC_1 0,1 /*EtherCAT address on the bus*/#define VID_PID 0x00000009, 0x00009252 /*Vendor ID, product code*/uint8_t *domain1_pd = NULL;unsigned int slave0_6000_01;unsigned int slave0_6000_01_bit;unsigned int slave0_6000_02;unsigned int slave0_6000_02_bit;unsigned int slave0_6000_03;unsigned int slave0_6000_03_bit;unsigned int slave0_6000_04;unsigned int slave0_6000_04_bit;unsigned int slave0_6000_05;unsigned int slave0_6000_05_bit;unsigned int slave0_6000_06;unsigned int slave0_6000_06_bit;unsigned int slave0_6000_07;unsigned int slave0_6000_07_bit;unsigned int slave0_6000_08;unsigned int slave0_6000_08_bit;unsigned int slave0_7010_01;unsigned int slave0_7010_01_bit;unsigned int slave0_7010_02;unsigned int slave0_7010_02_bit;unsigned int slave0_7010_03;unsigned int slave0_7010_03_bit;unsigned int slave0_7010_04;unsigned int slave0_7010_04_bit;unsigned int slave0_7010_05;unsigned int slave0_7010_05_bit;unsigned int slave0_7010_06;unsigned int slave0_7010_06_bit;unsigned int slave0_7010_07;unsigned int slave0_7010_07_bit;unsigned int slave0_7010_08;unsigned int slave0_7010_08_bit;unsigned int slave1_6000_01;unsigned int slave1_6000_01_bit;unsigned int slave1_6000_02;unsigned int slave1_6000_02_bit;unsigned int slave1_6000_03;unsigned int slave1_6000_03_bit;unsigned int slave1_6000_04;unsigned int slave1_6000_04_bit;unsigned int slave1_6000_05;unsigned int slave1_6000_05_bit;unsigned int slave1_6000_06;unsigned int slave1_6000_06_bit;unsigned int slave1_6000_07;unsigned int slave1_6000_07_bit;unsigned int slave1_6000_08;unsigned int slave1_6000_08_bit;unsigned int slave1_7010_01;unsigned int slave1_7010_01_bit;unsigned int slave1_7010_02;unsigned int slave1_7010_02_bit;unsigned int slave1_7010_03;unsigned int slave1_7010_03_bit;unsigned int slave1_7010_04;unsigned int slave1_7010_04_bit;unsigned int slave1_7010_05;unsigned int slave1_7010_05_bit;unsigned int slave1_7010_06;unsigned int slave1_7010_06_bit;unsigned int slave1_7010_07;unsigned int slave1_7010_07_bit;unsigned int slave1_7010_08;unsigned int slave1_7010_08_bit;const static ec_pdo_entry_reg_t domain1_regs[] = &#123; &#123;PANASONIC_0, VID_PID, 0x6000, 1, &amp;slave0_6000_01, &amp;slave0_6000_01_bit&#125;, &#123;PANASONIC_0, VID_PID, 0x6000, 2, &amp;slave0_6000_02, &amp;slave0_6000_02_bit&#125;, &#123;PANASONIC_0, VID_PID, 0x6000, 3, &amp;slave0_6000_03, &amp;slave0_6000_03_bit&#125;, &#123;PANASONIC_0, VID_PID, 0x6000, 4, &amp;slave0_6000_04, &amp;slave0_6000_04_bit&#125;, &#123;PANASONIC_0, VID_PID, 0x6000, 5, &amp;slave0_6000_05, &amp;slave0_6000_05_bit&#125;, &#123;PANASONIC_0, VID_PID, 0x6000, 6, &amp;slave0_6000_06, &amp;slave0_6000_06_bit&#125;, &#123;PANASONIC_0, VID_PID, 0x6000, 7, &amp;slave0_6000_07, &amp;slave0_6000_07_bit&#125;, &#123;PANASONIC_0, VID_PID, 0x6000, 8, &amp;slave0_6000_08, &amp;slave0_6000_08_bit&#125;, &#123;PANASONIC_0, VID_PID, 0x7010, 1, &amp;slave0_7010_01, &amp;slave0_7010_01_bit&#125;, &#123;PANASONIC_0, VID_PID, 0x7010, 2, &amp;slave0_7010_02, &amp;slave0_7010_02_bit&#125;, &#123;PANASONIC_0, VID_PID, 0x7010, 3, &amp;slave0_7010_03, &amp;slave0_7010_03_bit&#125;, &#123;PANASONIC_0, VID_PID, 0x7010, 4, &amp;slave0_7010_04, &amp;slave0_7010_04_bit&#125;, &#123;PANASONIC_0, VID_PID, 0x7010, 5, &amp;slave0_7010_05, &amp;slave0_7010_05_bit&#125;, &#123;PANASONIC_0, VID_PID, 0x7010, 6, &amp;slave0_7010_06, &amp;slave0_7010_06_bit&#125;, &#123;PANASONIC_0, VID_PID, 0x7010, 7, &amp;slave0_7010_07, &amp;slave0_7010_07_bit&#125;, &#123;PANASONIC_0, VID_PID, 0x7010, 8, &amp;slave0_7010_08, &amp;slave0_7010_08_bit&#125;, &#123;PANASONIC_1, VID_PID, 0x6000, 1, &amp;slave1_6000_01, &amp;slave1_6000_01_bit&#125;, &#123;PANASONIC_1, VID_PID, 0x6000, 2, &amp;slave1_6000_02, &amp;slave1_6000_02_bit&#125;, &#123;PANASONIC_1, VID_PID, 0x6000, 3, &amp;slave1_6000_03, &amp;slave1_6000_03_bit&#125;, &#123;PANASONIC_1, VID_PID, 0x6000, 4, &amp;slave1_6000_04, &amp;slave1_6000_04_bit&#125;, &#123;PANASONIC_1, VID_PID, 0x6000, 5, &amp;slave1_6000_05, &amp;slave1_6000_05_bit&#125;, &#123;PANASONIC_1, VID_PID, 0x6000, 6, &amp;slave1_6000_06, &amp;slave1_6000_06_bit&#125;, &#123;PANASONIC_1, VID_PID, 0x6000, 7, &amp;slave1_6000_07, &amp;slave1_6000_07_bit&#125;, &#123;PANASONIC_1, VID_PID, 0x6000, 8, &amp;slave1_6000_08, &amp;slave1_6000_08_bit&#125;, &#123;PANASONIC_1, VID_PID, 0x7010, 1, &amp;slave1_7010_01, &amp;slave1_7010_01_bit&#125;, &#123;PANASONIC_1, VID_PID, 0x7010, 2, &amp;slave1_7010_02, &amp;slave1_7010_02_bit&#125;, &#123;PANASONIC_1, VID_PID, 0x7010, 3, &amp;slave1_7010_03, &amp;slave1_7010_03_bit&#125;, &#123;PANASONIC_1, VID_PID, 0x7010, 4, &amp;slave1_7010_04, &amp;slave1_7010_04_bit&#125;, &#123;PANASONIC_1, VID_PID, 0x7010, 5, &amp;slave1_7010_05, &amp;slave1_7010_05_bit&#125;, &#123;PANASONIC_1, VID_PID, 0x7010, 6, &amp;slave1_7010_06, &amp;slave1_7010_06_bit&#125;, &#123;PANASONIC_1, VID_PID, 0x7010, 7, &amp;slave1_7010_07, &amp;slave1_7010_07_bit&#125;, &#123;PANASONIC_1, VID_PID, 0x7010, 8, &amp;slave1_7010_08, &amp;slave1_7010_08_bit&#125;, &#123;&#125;&#125;;/*****************************************************************************//* Slave 0, &quot;LAN9252-EVB-HBI&quot; * Vendor ID: 0x00000009 * Product code: 0x00009252 * Revision number: 0x00000001 */ec_pdo_entry_info_t slave_0_pdo_entries[] = &#123; &#123;0x7010, 0x01, 1&#125;, /* LED 1 */ &#123;0x7010, 0x02, 1&#125;, /* LED 2 */ &#123;0x7010, 0x03, 1&#125;, /* LED 3 */ &#123;0x7010, 0x04, 1&#125;, /* LED 4 */ &#123;0x7010, 0x05, 1&#125;, /* LED 5 */ &#123;0x7010, 0x06, 1&#125;, /* LED 6 */ &#123;0x7010, 0x07, 1&#125;, /* LED 7 */ &#123;0x7010, 0x08, 1&#125;, /* LED 8 */ &#123;0x0000, 0x00, 8&#125;, /* None */ &#123;0x6000, 0x01, 1&#125;, /* Switch 1 */ &#123;0x6000, 0x02, 1&#125;, /* Switch 2 */ &#123;0x6000, 0x03, 1&#125;, /* Switch 3 */ &#123;0x6000, 0x04, 1&#125;, /* Switch 4 */ &#123;0x6000, 0x05, 1&#125;, /* Switch 5 */ &#123;0x6000, 0x06, 1&#125;, /* Switch 6 */ &#123;0x6000, 0x07, 1&#125;, /* Switch 7 */ &#123;0x6000, 0x08, 1&#125;, /* Switch 8 */ &#123;0x0000, 0x00, 8&#125;, /* None */ &#123;0x6020, 0x01, 1&#125;, /* Underrange */ &#123;0x6020, 0x02, 1&#125;, /* Overrange */ &#123;0x6020, 0x03, 2&#125;, /* Limit 1 */ &#123;0x6020, 0x05, 2&#125;, /* Limit 2 */ &#123;0x0000, 0x00, 8&#125;, /* Gap */ &#123;0x1802, 0x07, 1&#125;, /* TxPDOState */ &#123;0x1802, 0x09, 1&#125;, /* TxPDO Toggle */ &#123;0x6020, 0x11, 16&#125;, /* Analog input */&#125;;ec_pdo_info_t slave_0_pdos[] = &#123; &#123;0x1601, 9, slave_0_pdo_entries + 0&#125;, /* DO Outputs */ &#123;0x1a00, 9, slave_0_pdo_entries + 9&#125;, /* DI Inputs */ &#123;0x1a02, 8, slave_0_pdo_entries + 18&#125;, /* AI TxPDO-Map */&#125;;ec_sync_info_t slave_0_syncs[] = &#123; &#123;0, EC_DIR_OUTPUT, 0, NULL, EC_WD_DISABLE&#125;, &#123;1, EC_DIR_INPUT, 0, NULL, EC_WD_DISABLE&#125;, &#123;2, EC_DIR_OUTPUT, 1, slave_0_pdos + 0, EC_WD_ENABLE&#125;, &#123;3, EC_DIR_INPUT, 2, slave_0_pdos + 1, EC_WD_DISABLE&#125;, &#123;0xff&#125;&#125;;/* Slave 1, &quot;LAN9252-EVB-HBI&quot; * Vendor ID: 0x00000009 * Product code: 0x00009252 * Revision number: 0x00000001 */ec_pdo_entry_info_t slave_1_pdo_entries[] = &#123; &#123;0x7010, 0x01, 1&#125;, /* LED 1 */ &#123;0x7010, 0x02, 1&#125;, /* LED 2 */ &#123;0x7010, 0x03, 1&#125;, /* LED 3 */ &#123;0x7010, 0x04, 1&#125;, /* LED 4 */ &#123;0x7010, 0x05, 1&#125;, /* LED 5 */ &#123;0x7010, 0x06, 1&#125;, /* LED 6 */ &#123;0x7010, 0x07, 1&#125;, /* LED 7 */ &#123;0x7010, 0x08, 1&#125;, /* LED 8 */ &#123;0x0000, 0x00, 8&#125;, /* None */ &#123;0x6000, 0x01, 1&#125;, /* Switch 1 */ &#123;0x6000, 0x02, 1&#125;, /* Switch 2 */ &#123;0x6000, 0x03, 1&#125;, /* Switch 3 */ &#123;0x6000, 0x04, 1&#125;, /* Switch 4 */ &#123;0x6000, 0x05, 1&#125;, /* Switch 5 */ &#123;0x6000, 0x06, 1&#125;, /* Switch 6 */ &#123;0x6000, 0x07, 1&#125;, /* Switch 7 */ &#123;0x6000, 0x08, 1&#125;, /* Switch 8 */ &#123;0x0000, 0x00, 8&#125;, /* None */ &#123;0x6020, 0x01, 1&#125;, /* Underrange */ &#123;0x6020, 0x02, 1&#125;, /* Overrange */ &#123;0x6020, 0x03, 2&#125;, /* Limit 1 */ &#123;0x6020, 0x05, 2&#125;, /* Limit 2 */ &#123;0x0000, 0x00, 8&#125;, /* Gap */ &#123;0x1802, 0x07, 1&#125;, /* TxPDOState */ &#123;0x1802, 0x09, 1&#125;, /* TxPDO Toggle */ &#123;0x6020, 0x11, 16&#125;, /* Analog input */&#125;;ec_pdo_info_t slave_1_pdos[] = &#123; &#123;0x1601, 9, slave_1_pdo_entries + 0&#125;, /* DO Outputs */ &#123;0x1a00, 9, slave_1_pdo_entries + 9&#125;, /* DI Inputs */ &#123;0x1a02, 8, slave_0_pdo_entries + 18&#125;, /* AI TxPDO-Map */&#125;;ec_sync_info_t slave_1_syncs[] = &#123; &#123;0, EC_DIR_OUTPUT, 0, NULL, EC_WD_DISABLE&#125;, &#123;1, EC_DIR_INPUT, 0, NULL, EC_WD_DISABLE&#125;, &#123;2, EC_DIR_OUTPUT, 1, slave_0_pdos + 0, EC_WD_ENABLE&#125;, &#123;3, EC_DIR_INPUT, 2, slave_0_pdos + 1, EC_WD_DISABLE&#125;, &#123;0xff&#125;&#125;;/*****************************************************************************/// Synchronise the distributed clocksvoid sync_distributed_clocks(void)&#123;#if SLAVE_REF uint32_t ref_time = 0; ecrt_master_reference_clock_time(master, &amp;ref_time);//获取参考时钟的低32位#else clock_gettime(CLOCK_TO_USE, &amp;sync_time); ecrt_master_sync_reference_clock_to(master, TIMESPEC2NS(sync_time));#endif ecrt_master_sync_slave_clocks(master);// call to sync slaves to ref slave&#125;/*****************************************************************************/// timespec相加struct timespec timespec_add(struct timespec time1, struct timespec time2)&#123; struct timespec result; if ((time1.tv_nsec + time2.tv_nsec) &gt;= NSEC_PER_SEC) &#123; result.tv_sec = time1.tv_sec + time2.tv_sec + 1; result.tv_nsec = time1.tv_nsec + time2.tv_nsec - NSEC_PER_SEC; &#125; else &#123; result.tv_sec = time1.tv_sec + time2.tv_sec; result.tv_nsec = time1.tv_nsec + time2.tv_nsec; &#125; return result;&#125;/*****************************************************************************/// Wait for the next periodvoid wait_period(void)&#123; clock_nanosleep(CLOCK_TO_USE, TIMER_ABSTIME, &amp;wakeupTime, NULL); ecrt_master_application_time(master, TIMESPEC2NS(wakeupTime)); wakeupTime = timespec_add(wakeupTime, cycletime);&#125;/*****************************************************************************/// 循环任务void cyclic_task()&#123; // wait for next period (using adjustable system time) wait_period(); // receive EtherCAT ecrt_master_receive(master); ecrt_domain_process(domain1); // 最大时钟偏移 diff_time_ns = ecrt_master_sync_monitor_process(master); // 返回所有从站时钟偏移中的最大值 fprintf(fp,&quot;%ld,&quot;,diff_time_ns); printf(&quot;最大时钟偏移 = %ld 纳秒\\n&quot;,diff_time_ns); // 程序运行时间 gettimeofday(&amp;end, NULL); uint32_t timeuse = 1000000*(end.tv_sec - start.tv_sec) + end.tv_usec-start.tv_usec; fprintf(fp,&quot;%ld\\n&quot;,timeuse); printf(&quot;程序运行时间 = %ld 微秒\\n&quot;,timeuse); // 流水灯逻辑 if(cycle_times &lt; 50)&#123; // 每500ms切换一次 cycle_times++; &#125;else&#123; cycle_times = 0; if(0&lt;led &amp;&amp; led&lt;7)&#123; LED[led-1] = 1; LED[led] = 0; led++; &#125;else if(led==7)&#123; LED[led-1] = 1; LED[led] = 0; led=0; &#125;else if(led==0)&#123; LED[7]=1; LED[0]=0; led=1; &#125; &#125; // write slave0 EC_WRITE_BIT(domain1_pd + slave0_7010_01, slave0_7010_01_bit, LED[0]); EC_WRITE_BIT(domain1_pd + slave0_7010_02, slave0_7010_02_bit, LED[1]); EC_WRITE_BIT(domain1_pd + slave0_7010_03, slave0_7010_03_bit, LED[2]); EC_WRITE_BIT(domain1_pd + slave0_7010_04, slave0_7010_04_bit, LED[3]); EC_WRITE_BIT(domain1_pd + slave0_7010_05, slave0_7010_05_bit, LED[4]); EC_WRITE_BIT(domain1_pd + slave0_7010_06, slave0_7010_06_bit, LED[5]); EC_WRITE_BIT(domain1_pd + slave0_7010_07, slave0_7010_07_bit, LED[6]); EC_WRITE_BIT(domain1_pd + slave0_7010_08, slave0_7010_08_bit, LED[7]); // write slave1 EC_WRITE_BIT(domain1_pd + slave1_7010_01, slave1_7010_01_bit, LED[0]); EC_WRITE_BIT(domain1_pd + slave1_7010_02, slave1_7010_02_bit, LED[1]); EC_WRITE_BIT(domain1_pd + slave1_7010_03, slave1_7010_03_bit, LED[2]); EC_WRITE_BIT(domain1_pd + slave1_7010_04, slave1_7010_04_bit, LED[3]); EC_WRITE_BIT(domain1_pd + slave1_7010_05, slave1_7010_05_bit, LED[4]); EC_WRITE_BIT(domain1_pd + slave1_7010_06, slave1_7010_06_bit, LED[5]); EC_WRITE_BIT(domain1_pd + slave1_7010_07, slave1_7010_07_bit, LED[6]); EC_WRITE_BIT(domain1_pd + slave1_7010_08, slave1_7010_08_bit, LED[7]); ecrt_domain_queue(domain1); sync_distributed_clocks(); // 读取所有从站0x092C寄存器(存储时钟偏移值) ecrt_master_sync_monitor_queue(master); ecrt_master_send(master);&#125;int main(int argc, char **argv)&#123; fp = fopen(&quot;/root/lan9252_test/diff_time_statistic.csv&quot;,&quot;w&quot;); master = ecrt_request_master(0); if (!master) return -1; domain1 = ecrt_master_create_domain(master); if (!domain1) return -1; // Create configuration for bus coupler slave0 = ecrt_master_slave_config(master, PANASONIC_0, VID_PID); if (!slave0) return -1; printf(&quot;Configuring PDOs...\\n&quot;); if (ecrt_slave_config_pdos(slave0, EC_END, slave_0_syncs)) &#123; fprintf(stderr, &quot;Failed to configure slave0 PDOs!\\n&quot;); exit(EXIT_FAILURE); &#125; else &#123; printf(&quot;*Success to configuring slave0 PDOs*\\n&quot;); &#125; slave1 = ecrt_master_slave_config(master, PANASONIC_1, VID_PID); if (!slave1) return -1; if (ecrt_slave_config_pdos(slave1, EC_END, slave_1_syncs)) &#123; fprintf(stderr, &quot;Failed to configure slave1 PDOs!\\n&quot;); exit(EXIT_FAILURE); &#125; else &#123; printf(&quot;*Success to configuring slave1 PDOs*\\n&quot;); &#125; if (ecrt_domain_reg_pdo_entry_list(domain1, domain1_regs)) &#123; fprintf(stderr, &quot;PDO entry registration failed!\\n&quot;); exit(EXIT_FAILURE); &#125; else&#123; printf(&quot;PDO entries sucess..\\n&quot;); &#125; // configure SYNC signals for this slave ecrt_slave_config_dc(slave0, 0x0300, cycle_t, 0, 0, 0); ecrt_slave_config_dc(slave1, 0x0300, cycle_t, 0, 0, 0); ecrt_master_select_reference_clock(master, slave0); printf(&quot;Activating master...\\n&quot;); if (ecrt_master_activate(master)) return -1; if (!(domain1_pd = ecrt_domain_data(domain1))) &#123; return -1; &#125; clock_gettime(CLOCK_TO_USE, &amp;wakeupTime); printf(&quot;Start running...\\n&quot;); gettimeofday(&amp;start, NULL); while(1)&#123; cyclic_task(); &#125;&#125;","categories":[{"name":"C","slug":"C","permalink":"http://zhongriqian.github.io/categories/C/"}],"tags":[{"name":"EtherCAT","slug":"EtherCAT","permalink":"http://zhongriqian.github.io/tags/EtherCAT/"},{"name":"C","slug":"C","permalink":"http://zhongriqian.github.io/tags/C/"},{"name":"Linux","slug":"Linux","permalink":"http://zhongriqian.github.io/tags/Linux/"}]},{"title":"多网卡主机Docker网络配置问题","slug":"多网卡主机Docker网络配置问题","date":"2023-02-19T16:00:00.000Z","updated":"2023-02-21T06:44:45.884Z","comments":true,"path":"2023/02/20/多网卡主机Docker网络配置问题/","link":"","permalink":"http://zhongriqian.github.io/2023/02/20/%E5%A4%9A%E7%BD%91%E5%8D%A1%E4%B8%BB%E6%9C%BADocker%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/","excerpt":"","text":"测试环境使用树莓派作为多网卡主机，其具备两张网卡，eth0和wlan0。另外需要一台PC用于测试与树莓派上容器的通信。将两台设备接入同一WiFi，然后再将两设备用网线直连。这样两设备即可以通过WiFi通信，也可以通过网线通信。 WiFi网段为192.168.31.0&#x2F;24，树莓派IP为192.168.31.154，PC的IP为192.168.31.69。 网线连接的局域网网段为169.254.0.0&#x2F;16，树莓派IP为169.254.140.68，PC的IP为169.254.140.66。 在树莓派上部署容器（容器为PLC运行环境容器），并对容器做不同的docker网络配置，测试PC与容器的通信，包括PC上的PLC开发环境软件（IDE）是否能接入容器，以及从容器内部是否能ping通PC。 1234567891011121314151617# 树莓派网卡信息2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000 link/ether dc:a6:32:de:1f:25 brd ff:ff:ff:ff:ff:ff inet 169.254.140.68/16 brd 169.254.255.255 scope global noprefixroute eth0 valid_lft forever preferred_lft forever inet6 fe80::9b39:2105:8832:4cf6/64 scope link valid_lft forever preferred_lft forever3: wlan0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether dc:a6:32:de:1f:26 brd ff:ff:ff:ff:ff:ff inet 192.168.31.154/24 brd 192.168.31.255 scope global dynamic noprefixroute wlan0 valid_lft 36699sec preferred_lft 31299sec inet6 fd00:6868:6868::b91/128 scope global dynamic noprefixroute valid_lft 36696sec preferred_lft 36696sec inet6 fd00:6868:6868:0:77e8:ee3:7b24:7a36/64 scope global mngtmpaddr noprefixroute valid_lft forever preferred_lft forever inet6 fe80::215f:7f6a:a210:4d05/64 scope link valid_lft forever preferred_lft forever 1234567891011121314151617# PC网卡信息以太网适配器 以太网 2: 连接特定的 DNS 后缀 . . . . . . . : 本地链接 IPv6 地址. . . . . . . . : fe80::62de:7603:51d9:79cc%17 IPv4 地址 . . . . . . . . . . . . : 169.254.140.66 子网掩码 . . . . . . . . . . . . : 255.255.0.0 默认网关. . . . . . . . . . . . . :无线局域网适配器 WLAN: 连接特定的 DNS 后缀 . . . . . . . : IPv6 地址 . . . . . . . . . . . . : fd00:6868:6868::69 IPv6 地址 . . . . . . . . . . . . : fd00:6868:6868:0:dbe:a764:e44b:ccec 临时 IPv6 地址. . . . . . . . . . : fd00:6868:6868:0:314c:b64b:89c7:1ef7 本地链接 IPv6 地址. . . . . . . . : fe80::b5c6:65b9:81b9:948f%16 IPv4 地址 . . . . . . . . . . . . : 192.168.31.69 子网掩码 . . . . . . . . . . . . : 255.255.255.0 默认网关. . . . . . . . . . . . . : fe80::cabf:4cff:fe4b:76d7%16 192.168.31.1 入向网络配置 入向：网络内其他设备访问主机上部署的容器 host模式使用host网络模式创建容器，容器直接使用主机的网络配置。 1docker run -it --net=host 0375866a09cd 所以PC上的IDE以树莓派的两个IP（169.254.140.68、192.168.31.154）作为目的地址都可以接入RTE。 bridge模式（不绑定网卡）使用bridge网络模式创建容器，会将容器接入docker0虚拟网桥下，网桥网段一般为172.17.0.0&#x2F;16。这种模式下，主机所在网段内的其他设备无法直接访问主机上的容器，需要在容器与主机间做端口映射。 1docker run -it --net=bridge -p 3000:3000 0375866a09cd 因为没有绑定网卡，只设置了端口映射，所以IDE以树莓派两个IP（169.254.140.68、192.168.31.154）作为目的地址都可以接入RTE。 bridge模式（绑定网卡）bridge模式创建容器，可以在设置端口映射时指定网卡IP，这样网络内其他设备只能从指定的主机网卡IP访问到容器。 1docker run -it --net=bridge -p 192.168.31.154:3000:3000 0375866a09cd 使用上面命令创建容器后，PC上的IDE只有把树莓派IP 192.168.31.154作为目的地址，才能访问到RTE容器。 相应的，如果创建容器时设置容器绑定到169.254.140.68，那IDE只有把树莓派IP 169.254.140.68作为目的地址，才能访问到RTE容器。 出向网络配置 出向：主机上部署的容器访问网络内其他设备 host模式在容器内ping主机所在的两个网段内的其他设备（如PC的两个网卡IP：192.168.31.69、169.254.140.66）都可以ping通。 bridge模式使用bridege模式创建容器，可以使用自带的docker0网桥，但缺点是创建容器时不能指定IP。使用自己创建的docker网桥，可以解决这个问题。另外对于docker0以及所有新建的docker网桥，系统会自动添加一条路由规则，使网桥网段内的所有容器都可以访问到主机所在的所有网段。使用命令“iptables -t nat -nvL –line-numbers”查看路由规则。如下面POSTROUTING链中的第一条规则，docker0网段（172.17.0.0&#x2F;16）下的容器可以访问主机所在的所有网段。 123Chain POSTROUTING (policy ACCEPT 0 packets, 0 bytes)num pkts bytes target prot opt in out source destination 1 0 0 MASQUERADE all -- * !docker0 172.17.0.0/16 0.0.0.0/0 新创建一个名为docker1的docker网络后，重新查看发现多出一条规则。 12# 创建网络（此处新建的网络本质也是bridge模式）docker network create --dirver bridge --subnet 172.18.0.0/16 --opt &quot;com.docker.network.bridge.name&quot;=&quot;docker1&quot; docker1 1234Chain POSTROUTING (policy ACCEPT 0 packets, 0 bytes)num pkts bytes target prot opt in out source destination 1 0 0 MASQUERADE all -- * !docker1 172.18.0.0/16 0.0.0.0/0 2 17 1234 MASQUERADE all -- * !docker0 172.17.0.0/16 0.0.0.0/0 然后创建容器，网络使用自己创建的docker1，但就像前面提到的，每个docker网络自动添加的路由规则，会使docker网络下的容器能访问到主机所在的所有网段。创建两个容器（rte1、rte2）测试一下。 123#创建容器，加入docker1docker run -d --net docker1 -p 3001:3000 --name rte1 0375866a09cddocker run -d --net docker1 -p 3001:3000 --name rte2 0375866a09cd 创建容器后，查看规则，没有针对容器IP的出向规则，只有针对整个网段的。 123456Chain POSTROUTING (policy ACCEPT 0 packets, 0 bytes)num pkts bytes target prot opt in out source destination 1 0 0 MASQUERADE all -- * !docker1 172.18.0.0/16 0.0.0.0/0 2 17 1234 MASQUERADE all -- * !docker0 172.17.0.0/16 0.0.0.0/0 3 0 0 MASQUERADE tcp -- * * 172.18.0.2 172.18.0.2 tcp dpt:30004 0 0 MASQUERADE tcp -- * * 172.18.0.3 172.18.0.3 tcp dpt:3000 从两个容器内向192.168.31.0&#x2F;24和169.254.0.0&#x2F;16两个网段ping，发现都能ping通。 如果想让某个容器只能访问192.168.31.0&#x2F;24网段，另一个容器只能访问169.254.0.0&#x2F;16网段，可以手动添加路由规则。 再创建两个容器（rte3、rte4），在创建时指定两个容器的IP。 123#创建容器，加入docker1，指定IPdocker run -d --net docker1 --ip 172.18.0.33 -p 3002:3000 --name rte3 0375866a09cddocker run -d --net docker1 --ip 172.18.0.44 -p 3004:3000 --name rte4 0375866a09cd 此时新建的两个容器（rte3、4）都在原本路由规则覆盖下，所以先删除docker1网络自动添加的路由规则。以规则序号为目标删除。 12# 删除POSTROUTING链下的序号1的规则iptables -t nat -D POSTROUTING 1 重新查看路由规则，docker1的出向路由规则已被删除。在rte3、4内向两个网段ping，都ping不通。 1234567Chain POSTROUTING (policy ACCEPT 0 packets, 0 bytes)num pkts bytes target prot opt in out source destination 1 17 1234 MASQUERADE all -- * !docker0 172.17.0.0/16 0.0.0.0/0 2 0 0 MASQUERADE tcp -- * * 172.18.0.2 172.18.0.2 tcp dpt:30003 0 0 MASQUERADE tcp -- * * 172.18.0.3 172.18.0.3 tcp dpt:30004 0 0 MASQUERADE tcp -- * * 172.18.0.33 172.18.0.33 tcp dpt:30005 0 0 MASQUERADE tcp -- * * 172.18.0.44 172.18.0.44 tcp dpt:3000 然后手动添加规则，完成目标需求。 12345# 配置nat，容器rte3向外发送的数据包源IP转换成192.168.31.154iptables -t nat -I POSTROUTING -p all -s 172.18.0.33 -j SNAT --to-source 192.168.31.154# 配置nat，容器rte4向外发送的数据包源IP转换成169.254.140.66iptables -t nat -I POSTROUTING -p all -s 172.18.0.44 -j SNAT --to-source 169.254.140.68 123456789Chain POSTROUTING (policy ACCEPT 0 packets, 0 bytes)num pkts bytes target prot opt in out source destination 1 0 0 SNAT all -- * * 172.18.0.44 0.0.0.0/0 to:169.254.140.682 0 0 SNAT all -- * * 172.18.0.33 0.0.0.0/0 to:192.168.31.1543 17 1234 MASQUERADE all -- * !docker0 172.17.0.0/16 0.0.0.0/0 4 0 0 MASQUERADE tcp -- * * 172.18.0.2 172.18.0.2 tcp dpt:30005 0 0 MASQUERADE tcp -- * * 172.18.0.3 172.18.0.3 tcp dpt:30006 0 0 MASQUERADE tcp -- * * 172.18.0.33 172.18.0.33 tcp dpt:30007 0 0 MASQUERADE tcp -- * * 172.18.0.44 172.18.0.44 tcp dpt:3000 配置完成后，再次测试，发现在容器rte3中，ping 192.168.31.69能通，ping 169.254.140.66不通；在容器rte4中，ping 169.254.140.66能通，ping 192.168.31.69不通，和目标需求一致。 当然除了可以添加针对IP的规则，也可以添加针对网段的规则，比如：创建了两个docker网络（docker11、docker22），希望docker11下的容器只能访问网段192.168.31.0&#x2F;24，docker22下的容器只能访问网段169.254.0.0&#x2F;16。可以如下配置。 1234567# 创建docker网络docker network create --dirver bridge --subnet 172.19.0.0/16 --opt &quot;com.docker.network.bridge.name&quot;=&quot;docker11&quot; docker11docker network create --dirver bridge --subnet 172.20.0.0/16 --opt &quot;com.docker.network.bridge.name&quot;=&quot;docker22&quot; docker22# 配置natiptables -t nat -I POSTROUTING -p all -s 172.19.0.0/16 -j SNAT --to-source 192.168.31.154iptables -t nat -I POSTROUTING -p all -s 172.20.0.0/16 -j SNAT --to-source 169.254.140.68 总结 入向（网络内其他设备到主机上的容器）：创建容器时通过参数（-p）绑定某一网卡后，网络内其他设备只能通过容器绑定的网卡IP访问容器 出向（主机上的容器到网络内其他设备）：配置nat，将容器IP转换为网卡IP，从而使容器能够访问网卡IP所在网段内的其他设备","categories":[{"name":"Docker","slug":"Docker","permalink":"http://zhongriqian.github.io/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://zhongriqian.github.io/tags/Docker/"}]},{"title":"Socket网络编程","slug":"Socket网络编程","date":"2023-02-07T16:00:00.000Z","updated":"2023-02-08T06:23:00.065Z","comments":true,"path":"2023/02/08/Socket网络编程/","link":"","permalink":"http://zhongriqian.github.io/2023/02/08/Socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","excerpt":"","text":"结构体 各类结构体以不同方式存放不同类型、不同数量的Socket信息，作为不同Socket接口函数的输入参数使用 in_addr 表示32位的IPv4地址 123456789#include &lt;arpa/inet.h&gt;// 用于表示32位的IPv4地址struct in_addr&#123; in_addr_t s_addr;&#125;// int_addr_t类型为unsigned int，长度为4字节（32位），字节序为网络顺序（大端字节序）// 如IP地址192.168.3.144，用int_addr_t类型存储为0Xc0a80390 sockaddr 套接字结构 123456789#include &lt;sys/socket.h&gt;struct sockaddr&#123; sa_family_t sin_family; // 协议族 char sa_data[14]; // 套接字中的目标IP和端口&#125;// sa_family_t类型为unsigned short，长度为2字节（16位）// 取值包括：AF_INET、AF_INET6、AF_UNSPE sockaddr_in 套接字结构 12345678910#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;struct sockaddr_in&#123; sa_family_t sin_family; // 协议族 unsigned short sin_port; // 端口号 struct in_addr sin_addr; // IP地址结构体 char sin_zero[8]; // 填充，为了与sockaddr结构体在内存中对齐，方便相互转换&#125; 函数字节序转换 字节序指在内存中存放大于一个字节的数据时，数据各字节的存放顺序。字节序可分为： 大端字节序：高位字节在前，低位字节在后 小端字节序：低位字节在前，高位字节在后 设计两种字节序的原因：大端字节序符合人类的读写习惯，比如我们想存放“一千二百三十四”这个十进制数字（转换为十六进制为0x04D2），用大端字节序存储后，当我们读取时还是0x04D2。但如果用小端字节序存储，读取时就变为0xD204。虽然小端字节序不符合人类读写习惯，但有利于提高计算效率，因为计算机计算时都是从数据的低位开始计算。 主机字节序：小端字节序网络字节序：大端字节序 普通数据的字节序转换主机字节序—&gt;网络字节序 功能：无符号32位&#x2F;16位整型数据转换参数：主机字节序数据返回值：网络字节序数据 1234#include &lt;arpa/inet.h&gt;uint32_t htonl(uint32_t hostlong);uint16_t htons(uint16_t hostshort); 网络字节序—&gt;主机字节序 功能：无符号32位&#x2F;16位整型数据转换参数：网络字节序数据返回值：主机字节序数据 1234#include &lt;arpa/inet.h&gt;uint32_t ntohl(uint32_t netlong);uint16_t ntohs(uint16_t netshort); IP地址的字节序转换字符串—&gt;网络字节序inet_pton 参数af：地址协议族（AF_INET、AF_INET6）参数strptr：指向IP字符串存储地址的指针参数addrptr：指向网络字节序IP数据存储地址的指针返回值：成功返回1，输入的IP地址无效返回0，出错返回-1 123#include &lt;arpa/inet.h&gt;int inet_pton(int af, const char *strptr, void *addrptr); inet_aton 参数cp：指向IP字符串存储地址的指针参数inp：指向in_addr结构体的指针，结构体内s_addr存储转换后的格式为网络字节序的32位二进制格式的IP返回值：成功返回非0，IP地址无效返回0 123#include &lt;arpa/inet.h&gt;int inet_aton(const char *cp, struct in_addr *inp); inet_addr 参数cp：指向IP字符串存储地址的指针返回值：in_addr_t类型变量，存储网络字节序的32位二进制格式的IP 123#include &lt;arpa/inet.h&gt;in_addr_t inet_addr(const char *cp); 字符串—&gt;主机字节序inet_network 参数cp：指向IP字符串存储地址的指针返回值：in_addr_t类型变量，存储主机字节序的32位二进制格式的IP 123#include &lt;arpa/inet.h&gt;in_addr_t inet_network(const char *cp); 网络字节序—&gt;字符串inet_ntop 参数af：地址协议族参数addrptr：指向网络字节序IP数据存储地址的指针参数strptr：指向IP字符串存储地址的指针参数len：IP字符串存储地址空间大小返回值：成功返回参数strptr的指针，失败返回NULL且修改errno的值。 123#include &lt;arpa/inet.h&gt;const char *inet_ntop(int af, const void *addrptr, char *strptr, size_t len); inet_ntoa 参数in：in_addr结构体，结构体内s_addr存储网络字节序的32位二进制格式的IP返回值：指向IP字符串存储地址的指针 123#include &lt;arpa/inet.h&gt;char *inet_ntoa(struct in_addr in); 测试 测试inet_pton、inet_ntop 1234567891011121314151617181920212223#include &lt;stdio.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;string.h&gt;int main()&#123; // 测试inet_pton char ip_str[] =&quot;193.168.1.10&quot;; in_addr_t ip_addr; int re = inet_pton(AF_INET, ip_str, (void *)&amp;ip_addr); printf(&quot;inet_pton返回值 = %d\\n&quot;,re); // inet_pton返回值 = 1 printf(&quot;ip_addr = %d\\n&quot;,ip_addr); // ip_addr = 167880897 printf(&quot;-------\\n&quot;); // 测试inet_ntop char ip_str2[INET_ADDRSTRLEN]; const char *re2 = inet_ntop(AF_INET, (const void *)&amp;ip_addr, ip_str2, sizeof(ip_str2)); printf(&quot;inet_ntop返回值 = %s\\n&quot;, re2); // inet_ntop返回值 = 193.168.1.10 printf(&quot;ip_str2 = %s\\n&quot;,ip_str2); // ip_str2 = 193.168.1.10&#125; 测试inet_aton、inet_ntoa 123456789101112131415161718192021#include &lt;stdio.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;string.h&gt;int main()&#123; // 测试inet_aton char ip_str[] =&quot;193.168.1.10&quot;; struct in_addr ip_addr; int re = inet_aton(ip_str, &amp;ip_addr); printf(&quot;inet_aton返回值 = %d\\n&quot;,re); // inet_aton返回值 = 1 printf(&quot;ip_addr.s_addr = %d\\n&quot;,ip_addr.s_addr); // ip_addr.s_addr = 167880897 printf(&quot;-------\\n&quot;); // 测试inet_ntoa char *ip_str2; ip_str2 = inet_ntoa(ip_addr); printf(&quot;inet_ntoa返回值 = %s\\n&quot;, ip_str2); // inet_ntoa返回值 = 193.168.1.10&#125; 测试inet_addr、inet_network 12345678910111213141516171819#include &lt;stdio.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;string.h&gt;int main()&#123; // 测试inet_addr char ip_str[] =&quot;193.168.1.10&quot;; struct in_addr ip_addr1; ip_addr1.s_addr = inet_addr(ip_str); printf(&quot;inet_addr返回值 = %u\\n&quot;,ip_addr1.s_addr); // inet_addr返回值 = 167880897 printf(&quot;-------\\n&quot;); // 测试inet_network struct in_addr ip_addr2; ip_addr2.s_addr = inet_network(ip_str); printf(&quot;inet_network返回值 = %u\\n&quot;, ip_addr2.s_addr); // inet_network返回值 = 3249013002&#125; IP地址处理IP地址—&gt;主机地址 参数in：in_addr结构体返回值：in_addr_t类型变量，存储主机字节序的主机地址数据 12345#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;in_addr_t inet_lnaof(struct in_addr in); IP地址—&gt;网络地址 参数in：in_addr结构体返回值：in_addr_t类型变量，存储主机字节序的网络地址数据 12345#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;in_addr_t inet_netof(struct in_addr in); 主机地址+网络地址—&gt;IP地址 参数net：in_addr_t类型变量，存储网络字节序的网络地址数据参数host：in_addr_t类型变量，存储网络字节序的主机地址数据返回值：in_addr结构体，内部包含in_addr_t类型变量，存储网络主机字节序的IP地址数据 12345#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;struct in_addr inet_makeaddr(in_addr_t net, in_addr_t host); 测试 测试inet_lnaof、inet_netof、inet_makeaddr 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;stdio.h&gt; #include &lt;arpa/inet.h&gt; #include &lt;string.h&gt;int main()&#123; char ip_str1[] = &quot;44.135.86.12&quot;; char ip_str2[] = &quot;172.16.23.95&quot;; char *ip_str; char *net_str1; char *net_str2; char *host_str1; char *host_str2; struct in_addr ip_addr1; struct in_addr ip_addr2; struct in_addr ip_addr; struct in_addr net_addr1; struct in_addr net_addr2; struct in_addr host_addr1; struct in_addr host_addr2; inet_aton(ip_str1,&amp;ip_addr1); // 将IP地址从字符串格式转为网络字节序的32位二进制格式 host_addr1.s_addr = inet_lnaof(ip_addr1); // 将IP地址转换为主机地址，格式为主机字节序的32位二进制格式 host_addr1.s_addr = htonl(host_addr1.s_addr); // 主机字节序转换为网络字节序 host_str1 = inet_ntoa(host_addr1); // 将主机地址从网络字节序的32位二进制格式转换为字符串格式 printf(&quot;主机地址：%s\\n&quot;,host_str1); net_addr1.s_addr = inet_netof(ip_addr1); // 将IP地址转换为网络地址，格式为主机字节序的32位二进制格式 net_addr1.s_addr = htonl(net_addr1.s_addr); // 主机字节序转换为网络字节序 net_str1 = inet_ntoa(net_addr1); // 将主机地址从网络字节序的32位二进制格式转换为字符串格式 printf(&quot;网络地址：%s\\n&quot;,net_str1); host_addr1.s_addr = ntohl(host_addr1.s_addr); // 网络字节序转换为主机字节序 net_addr1.s_addr = ntohl(net_addr1.s_addr); // 网络字节序转换为主机字节序 ip_addr = inet_makeaddr(net_addr1.s_addr, host_addr1.s_addr); // 网络地址和主机地址合成IP地址，格式为网络字节序的32位二进制格式 ip_str = inet_ntoa(ip_addr); // 将IP地址从网络字节序的32位二进制格式转换为字符串格式 printf(&quot;IP地址：%s\\n&quot;,ip_str); inet_aton(ip_str2,&amp;ip_addr2); host_addr2.s_addr = inet_lnaof(ip_addr2); host_addr2.s_addr = htonl(host_addr2.s_addr); host_str2 = inet_ntoa(host_addr2); printf(&quot;主机地址：%s\\n&quot;,host_str2); net_addr2.s_addr = inet_netof(ip_addr2); net_addr2.s_addr = htonl(net_addr2.s_addr); net_str2 = inet_ntoa(net_addr2); printf(&quot;网络地址：%s\\n&quot;,net_str2);&#125; 常规SocketCTCP服务端客户端UDP服务端客户端","categories":[{"name":"Linux","slug":"Linux","permalink":"http://zhongriqian.github.io/categories/Linux/"}],"tags":[{"name":"C","slug":"C","permalink":"http://zhongriqian.github.io/tags/C/"},{"name":"Linux","slug":"Linux","permalink":"http://zhongriqian.github.io/tags/Linux/"},{"name":"Socket","slug":"Socket","permalink":"http://zhongriqian.github.io/tags/Socket/"}]},{"title":"Linux常用网络命令","slug":"Linux常用网络命令","date":"2023-01-27T16:00:00.000Z","updated":"2023-02-16T07:24:14.176Z","comments":true,"path":"2023/01/28/Linux常用网络命令/","link":"","permalink":"http://zhongriqian.github.io/2023/01/28/Linux%E5%B8%B8%E7%94%A8%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4/","excerpt":"","text":"ifconfig功能 显示网络设备信息 常用参数示例 123456# 显示某网卡信息ifconfig eth0# 配置网卡IPifconfig ehx x.x.x.x netmask x.x.x.xifconfig eh0 192.168.10.2 netmask 255.255.255.0 ip功能 显示网络设备信息 常用参数示例 123456789# 显示网卡设备信息ip a# 显示网卡设备链路层信息ip linkip -s link# 查看所在局域网内设备MAC地址ip neighbor ping功能 发送ICMP包，检测网络状态 常用参数示例 1234567891011121314# 检测到IP为192.168.137.16主机的网络ping 192.168.137.16# 指定发送次数ping -c 10 192.168.137.16# 指定发送时间间隔（单位s，缺省值1s）ping -i 10 192.168.137.16# 指定持续发送时间（单位s）ping -w 10 192.168.137.16# 指定发送数据包字节数（缺省64字节，其中ICMP包头8字节、负载56字节，最大65535字节）ping -s 1000 192.168.137.16 route功能 显示和操作路由表 常用参数示例 1234567891011121314151617# 显示路由表route -nee# 添加主机路由route add -host 192.168.1.2 gw 172.16.0.1 dev eth0# 添加网络路由route add -net 192.168.0.0 netmask 255.255.255.0 gw 172.16.0.1 dev eth0route add -net 192.168.0.0/24 gw 172.16.0.1 dev eth0# 添加默认路由route add -net 0.0.0.0 netmask 0.0.0.0 gw 172.16.0.1route add -net 0.0.0.0/0 gw 172.16.0.1route add default gw 172.16.0.1# 删除路由route add -host 192.168.1.2 gw 172.16.0.1 dev eth0 netstat功能 查看网络状态、路由表、接口信息等 常用参数示例 1234567891011# 显示所有TCP协议相关信息，及其所属进程netstat -anpt# 显示所有UDP协议相关信息，及其所属进程netstat -anpu# 显示路由表netstat -r# 显示网卡信息netstat -i ss功能 获取socket信息 常用参数示例 12345# 显示所有TCP协议相关信息，及其所属进程ss -apt# 显示所有UDP协议相关信息，及其所属进程ss -apu traceroute功能 测试当前主机到目标主机间经过的网络节点 常用参数示例 12345# 检测当前主机到IP地址为192.168.1.1的主机间经过的网络节点traceroute 192.168.1.1# 检测当前主机到域名为www.baidu.com的主机间经过的网络节点traceroute www.baidu.com nslookup功能 域名解析 dig功能 域名解析 arp功能 操作arp缓冲区 常用参数示例 1234# 显示arp表（IP与MAC对于关系）arp -n# 显示arp表（主机名与MAC对应关系）arp -e nmap功能 端口扫描、网络扫描 常用参数示例 1234567891011# 查看本机开放的TCP端口nmap -sT 127.0.0.1# 查看本机开放的UDP端口nmap -sU 127.0.0.1# 扫描192.168.1.0/24网段中开放80端口的主机nmap -p 80 192.168.1.0/24# 扫描192.168.1.0/24网段中有哪些存活的主机nmap -n -sP 192.168.1.0/24","categories":[{"name":"Linux","slug":"Linux","permalink":"http://zhongriqian.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://zhongriqian.github.io/tags/Linux/"}]},{"title":"数采网关程序——Modbus-RTU与MQTT协议转换","slug":"数采网关程序——Modbus-RTU与MQTT协议转换","date":"2022-08-16T16:00:00.000Z","updated":"2023-01-28T08:53:58.637Z","comments":true,"path":"2022/08/17/数采网关程序——Modbus-RTU与MQTT协议转换/","link":"","permalink":"http://zhongriqian.github.io/2022/08/17/%E6%95%B0%E9%87%87%E7%BD%91%E5%85%B3%E7%A8%8B%E5%BA%8F%E2%80%94%E2%80%94Modbus-RTU%E4%B8%8EMQTT%E5%8D%8F%E8%AE%AE%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#include &lt;modbus.h&gt;#include &lt;unistd.h&gt;#include &lt;MQTTClient.h&gt;#define ADDRESS &quot;&quot;#define CLIENTID &quot;&quot;#define LOOP 10#define SERVER_ID 1#define ADDRESS_START 0#define ADDRESS_END 4#define CODE 1void publish(MQTTClient client, char* topic, char* payload) &#123; MQTTClient_message pubmsg = MQTTClient_message_initializer; pubmsg.payload = payload; pubmsg.payloadlen = strlen(pubmsg.payload); pubmsg.qos = 2; pubmsg.retained = 0; MQTTClient_deliveryToken token; MQTTClient_publishMessage(client, topic, &amp;pubmsg, &amp;token); MQTTClient_waitForCompletion(client, token, 1000L); printf(&quot;Message &#x27;%s&#x27; with delivery token %d delivered\\n&quot;, payload, token);&#125;int on_message(void *context, char *topicName, int topicLen, MQTTClient_message *message) &#123; char* payload = message-&gt;payload; printf(&quot;Received operation %s\\n&quot;, payload); MQTTClient_freeMessage(&amp;message); MQTTClient_free(topicName); return 1;&#125;int main(void)&#123; modbus_t *ctx; int rc; int nb_fail; int nb_loop; int addr; int nb; uint8_t *tab_rp_bits; uint16_t *tab_rp_registers; char buffer[100]; /*MQTT initialize*/ MQTTClient client; MQTTClient_create(&amp;client, ADDRESS, CLIENTID, MQTTCLIENT_PERSISTENCE_NONE, NULL); MQTTClient_connectOptions conn_opts = MQTTClient_connectOptions_initializer; conn_opts.username = &quot;&quot;; conn_opts.password = &quot;&quot;; MQTTClient_setCallbacks(client, NULL, NULL, on_message, NULL); int rc_mqtt; if ((rc_mqtt = MQTTClient_connect(client, &amp;conn_opts)) != MQTTCLIENT_SUCCESS) &#123; printf(&quot;Failed to connect, return code %d\\n&quot;, rc_mqtt); exit(-1); &#125; //create device publish(client, &quot;s/us&quot;, &quot;100,USTB_TEST,c8y_MQTTDevice&quot;); //set hardware information publish(client, &quot;s/us&quot;, &quot;110,S123456789,MQTT test model,Rev0.1&quot;); //listen for operation MQTTClient_subscribe(client, &quot;s/ds&quot;, 0); /* RTU */ ctx = modbus_new_rtu(&quot;/dev/ttyS1&quot;, 19200, &#x27;N&#x27;, 8, 1); modbus_set_slave(ctx, SERVER_ID); /* TCP */// ctx = modbus_new_tcp(&quot;127.0.0.1&quot;, 1502);// ctx = modbus_new_tcp(&quot;192.168.72.61&quot;, 502);// modbus_set_debug(ctx, TRUE); if (modbus_connect(ctx) == -1) &#123; fprintf(stderr, &quot;Connection failed: %s\\n&quot;, modbus_strerror(errno)); modbus_free(ctx); return -1; &#125; nb = ADDRESS_END - ADDRESS_START; if(CODE == 1 || CODE == 2)&#123; tab_rp_bits = (uint8_t *) malloc(nb * sizeof(uint8_t)); memset(tab_rp_bits, 0, nb * sizeof(uint8_t)); &#125; else&#123; tab_rp_registers = (uint16_t *) malloc(nb * sizeof(uint16_t)); memset(tab_rp_registers, 0, nb * sizeof(uint16_t)); &#125; nb_loop = nb_fail = 0; while (nb_loop++ &lt; LOOP) &#123; int i; addr = ADDRESS_START; switch(CODE)&#123; case 1: rc = modbus_read_bits(ctx, addr, nb, tab_rp_bits);break; // modbus功能码01 case 2: rc = modbus_read_input_bits(ctx, addr, nb, tab_rp_bits);break; // modbus功能码02 case 3: rc = modbus_read_registers(ctx, addr, nb, tab_rp_registers);break; // modbus功能码03 case 4: rc = modbus_read_input_registers(ctx, addr, nb, tab_rp_registers);break; // modbus功能码04 default: rc = 0; &#125; printf(&quot;&lt;&lt;\\n&quot;); if (rc != nb) &#123; printf(&quot;ERROR modbus_read_registers (%d)\\n&quot;, rc); printf(&quot;Address = %d, nb = %d\\n&quot;, addr, nb); nb_fail++; &#125; else &#123; for (i=0; i&lt;nb; i++) &#123; buffer[0] = &#x27;\\0&#x27;; switch(CODE)&#123; case 1: printf(&quot;Address = %d, Status = %X\\n&quot;, addr+i, tab_rp_bits[i]); sprintf(buffer,&quot;%s%s%d%s%d&quot;,&quot;200,&quot;, &quot;Register_Address_&quot;,ADDRESS_START+i, &quot;,ustb_test,&quot;, tab_rp_bits[i]); break; case 2:printf(&quot;Address = %d, Status = %X\\n&quot;, addr+i, tab_rp_bits[i]); sprintf(buffer,&quot;%s%s%d%s%d&quot;,&quot;200,&quot;, &quot;Register_Address_&quot;,ADDRESS_START+i, &quot;,ustb_test,&quot;, tab_rp_bits[i]); break; case 3:printf(&quot;Address = %d, Value = %d\\n&quot;, ADDRESS_START+i, tab_rp_registers[i]); sprintf(buffer,&quot;%s%s%d%s%d&quot;,&quot;200,&quot;, &quot;Register_Address_&quot;,ADDRESS_START+i, &quot;,ustb_test,&quot;, tab_rp_registers[i]); break; case 4:printf(&quot;Address = %d, Value = %d\\n&quot;, ADDRESS_START+i, tab_rp_registers[i]); sprintf(buffer,&quot;%s%s%d%s%d&quot;,&quot;200,&quot;, &quot;Register_Address_&quot;,ADDRESS_START+i, &quot;,ustb_test,&quot;, tab_rp_registers[i]); break; &#125; publish(client, &quot;s/us&quot;,buffer); sleep(1); &#125; &#125; printf(&quot;LOOP: %d, CODE: %d\\n&quot;, nb_loop, CODE); printf(&quot;Read: &quot;); if (nb_fail) printf(&quot;%d FAILS\\n&quot;, nb_fail); else printf(&quot;SUCCESS\\n&quot;); printf(&quot;&gt;&gt;\\n&quot;); &#125; /* Free the memory */ free(tab_rp_registers); /* Close the connection */ modbus_close(ctx); modbus_free(ctx); return 0;&#125;","categories":[{"name":"C","slug":"C","permalink":"http://zhongriqian.github.io/categories/C/"}],"tags":[{"name":"C","slug":"C","permalink":"http://zhongriqian.github.io/tags/C/"},{"name":"Modbus RTU","slug":"Modbus-RTU","permalink":"http://zhongriqian.github.io/tags/Modbus-RTU/"},{"name":"MQTT","slug":"MQTT","permalink":"http://zhongriqian.github.io/tags/MQTT/"}]},{"title":"Python计算TBS程序","slug":"Python计算TBS程序","date":"2022-05-15T16:00:00.000Z","updated":"2023-01-28T08:53:37.398Z","comments":true,"path":"2022/05/16/Python计算TBS程序/","link":"","permalink":"http://zhongriqian.github.io/2022/05/16/Python%E8%AE%A1%E7%AE%97TBS%E7%A8%8B%E5%BA%8F/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200from openpyxl import load_workbookimport mathclass N_PRB: &quot;&quot;&quot; 由给定参数获得分配给PDSCH的PRB（Physical resource block，物理资源块）数量 &quot;&quot;&quot; def __init__(self, file_path, scs, bw): &quot;&quot;&quot; 创建PRB查询对象 :param file_path: PRB表的路径（该表可由scs和bw查PRB值） :param scs: sub carrier spacing，子载波间隔（kHz） :param bw: bandwidth，载波带宽（MHz） &quot;&quot;&quot; self.table = load_workbook(file_path) self.sheet = self.table[&#x27;Sheet1&#x27;] self.scs = scs self.bw = bw def calculate_N_prb(self): &quot;&quot;&quot; 通过参数scs和bw查表得到PRB（Physical resource block，物理资源块）数量 :return:PRB（Physical resource block，物理资源块）数量 &quot;&quot;&quot; try: for line in range(3, 6): if self.scs == int(self.sheet[&#x27;A&#x27; + str(line)].value): for column in range(66, 78): if self.bw == int(self.sheet[chr(column) + &#x27;1&#x27;].value): N_prb = int(self.sheet[chr(column) + str(line)].value) print(&quot;scs=%dkHz，bw=%dMHz ===&gt; PRB数量=%d&quot; % (self.scs, self.bw, N_prb)) return N_prb except ValueError: print(&quot;calculate_N_prb运行失败，scs=%dkHz,bw=%dMHz无对应PRB值&quot; % (self.scs, self.bw))class TBS: &quot;&quot;&quot; 通过给定参数获得TBS（Transport Block Size，传输块大小）数值 &quot;&quot;&quot; def __init__(self, N_prb, file_path, Imcs): &quot;&quot;&quot; 创建Imcs表对象，相关参数赋值 :param N_prb:PRB（Physical resource block，物理资源块）数量 :param file_path:Imcs表的路径，该表可由Imcs（Modulation and Coding Scheme index，调制与编码策略索引）值 查对应qm（调制阶数）和R（码率） :param Imcs:Imcs（Modulation and Coding Scheme index，调制与编码策略索引） &quot;&quot;&quot; self.N_prb = N_prb self.table = load_workbook(file_path) self.sheet = self.table[&#x27;Sheet1&#x27;] self.N_rb_sc = 12 # 一个RB中的子载波个数 self.N_sh_symb = 13 # 一个时隙中分配给PDSCH的符号数 self.N_prb_oh = 0 # 由高层参数决定 self.N_prb_dmrs = 12 # 一个时隙中一个PRB宽度中DMRS占用的子载波，DMRS tpye1和DMRS type2两种类型 self.Imcs = Imcs # Imcs（Modulation and Coding Scheme index，调制与编码策略索引） def calculate_N_re(self): &quot;&quot;&quot; 计算给定带宽中一个时隙内分配给PDSCH的RE（Resource Element，资源元素）数量 :return: RE（Resource Element，资源元素）数量 &quot;&quot;&quot; try: N_re_t = min(156, self.N_rb_sc * self.N_sh_symb - self.N_prb_dmrs - self.N_prb_oh) N_re = int(N_re_t * self.N_prb) print(&quot;在包含%d个RB的带宽中，一个时隙内分配给PDSCH的RE数量=%d&quot; % (self.N_prb, N_re)) return N_re except TypeError: print(&quot;Calculate_N_re运行失败，重新设置scs与bw的值，以获取可用PRB数量值&quot;) def calculate_N_info(self): &quot;&quot;&quot; 计算信息比特数 :return:信息比特数 &quot;&quot;&quot; try: Nre = self.calculate_N_re() v = 1 for line in range(2, 34): if self.Imcs == int(self.sheet[&#x27;A&#x27; + str(line)].value): qm = int(self.sheet[&#x27;B&#x27; + str(line)].value) R = float(self.sheet[&#x27;c&#x27; + str(line)].value) / 1024 N_info = Nre * qm * v * R print(&quot;MAC层向物理层传输的一个TB中的信息比特数=%d bits&quot; % N_info) return N_info except TypeError: print(&quot;calculate_N_info运行失败，重新设置scs与bw的值，以获取可用PRB数量值&quot;) def calculate_q_N_info(self): &quot;&quot;&quot; 计算信息比特数的量化中间数 :return:信息比特数的量化中间数 &quot;&quot;&quot; try: Ninfo = self.calculate_N_info() if Ninfo &gt; 3824: n = int(math.log((Ninfo - 24), 2) - 5) q_N_info = max(3840, math.pow(2, n) * round((Ninfo - 24) / math.pow(2, n))) else: n = max(3, int(math.log(Ninfo, 2) - 6)) q_N_info = max(24, math.pow(2, n) * round(Ninfo / math.pow(2, n))) print(&quot;信息比特数的量化中间值=%d bits&quot; % q_N_info) return q_N_info except TypeError: print(&quot;calculate_q_N_info运行失败，重新设置scs与bw的值，以获取可用PRB数量值&quot;) def calculate_TBS(self): &quot;&quot;&quot; 计算TBS（Transport Block Size，传输块大小） :return: TBS（Transport Block Size，传输块大小） &quot;&quot;&quot; try: qNinfo = self.calculate_q_N_info() for line in range(2, 34): if self.Imcs == int(self.sheet[&#x27;A&#x27; + str(line)].value): R = float(self.sheet[&#x27;c&#x27; + str(line)].value) / 1024 if R &lt; 0.25: C = math.ceil(float(qNinfo + 24) / 3816) TBS = 8 * C * math.ceil((qNinfo + 24) / (8 * C)) - 24 else: C = math.ceil(float(qNinfo + 24) / 8424) if qNinfo &gt; 8424: TBS = 8 * C * math.ceil((qNinfo + 24) / (8 * C)) - 24 else: TBS = 8 * math.ceil((qNinfo + 24) / (8 * C)) - 24 print(&#x27;TBS = %d bits&#x27; % TBS) return TBS except TypeError: print(&quot;calculate_TBS运行失败，重新设置scs与bw的值，以获取可用PRB数量值&quot;)class N_bits: &quot;&quot;&quot; 计算在给定参数下，一个RB所含的比特数、一个OFDM符号所含比特数 &quot;&quot;&quot; def __init__(self, file_path, xQAM, scs, bw): &quot;&quot;&quot; :param file_path: PRB表的路径（该表可由scs和bw查PRB值） :param xQAM: 调制方式，16QAM, 64QAM and 256QAM :param scs: sub carrier spacing，子载波间隔（kHz） :param bw: bandwidth，载波带宽（MHz） &quot;&quot;&quot; self.table = load_workbook(file_path) self.sheet = self.table[&#x27;Sheet1&#x27;] self.xQAM = xQAM self.scs = scs self.bw = bw def calculate_N_RPB_bits(self): &quot;&quot;&quot; :return: 一个RB所含的比特数 &quot;&quot;&quot; N_prb_bits = math.log(self.xQAM, 2) * 12 print(&quot;选用%dQAM调制，一个RB所含比特数=%d bits&quot; % (self.xQAM, N_prb_bits)) return N_prb_bits def calculate_N_symb_bits(self): &quot;&quot;&quot; :return: 一个OFDM符号所含的比特数 &quot;&quot;&quot; try: for line in range(3, 6): if self.scs == int(self.sheet[&#x27;A&#x27; + str(line)].value): for column in range(66, 78): if self.bw == int(self.sheet[chr(column) + &#x27;1&#x27;].value): N_prb = int(self.sheet[chr(column) + str(line)].value) N_symb_bits = N_prb * math.log(self.xQAM, 2) * 12 print(&quot;scs=%dkHZ，bw=%dMHz，选用%dQAM调制，一个OFDM符号所含比特数=%d bits&quot; % (self.scs, self.bw, self.xQAM, N_symb_bits)) except ValueError: print(&quot;calculate_N_symb_bits运行失败，scs=%dkHz,bw=%dMHz无对应PRB值&quot; % (self.scs, self.bw))if __name__ == &#x27;__main__&#x27;: # 创建N_PRB对象,参数scs=30，bw=100 n = N_PRB(&#x27;maximum_transmission_bandwidth_configuration_Nrb.xlsx&#x27;, 15, 20) # 查询PRB数量 print(&quot;/---------------------------------------------------------------\\\\&quot;) Nprb = n.calculate_N_prb() print(&quot;\\\\---------------------------------------------------------------/&quot;) # 创建TBS对象 TBS1 = TBS(Nprb, &#x27;MCS index table 2 for PDSCH.xlsx&#x27;, 26) # TBS1.calculate_N_re() # TBS1.calculate_N_info() # TBS1.calculate_q_N_info() print(&quot;/---------------------------------------------------------------\\\\&quot;) TBS1.calculate_TBS() print(&quot;\\\\---------------------------------------------------------------/&quot;) # 创建N_bits对象 xQAM_RB = N_bits(&#x27;maximum_transmission_bandwidth_configuration_Nrb.xlsx&#x27;, 64, 30, 20) print(&quot;/---------------------------------------------------------------\\\\&quot;) xQAM_RB.calculate_N_RPB_bits() xQAM_RB.calculate_N_symb_bits() print(&quot;\\\\---------------------------------------------------------------/&quot;)","categories":[{"name":"Python","slug":"Python","permalink":"http://zhongriqian.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://zhongriqian.github.io/tags/Python/"},{"name":"5G","slug":"5G","permalink":"http://zhongriqian.github.io/tags/5G/"},{"name":"TBS","slug":"TBS","permalink":"http://zhongriqian.github.io/tags/TBS/"}]},{"title":"Python+Docker实现人脸识别远程监控系统","slug":"Python+Docker实现人脸识别远程监控系统","date":"2022-05-06T16:00:00.000Z","updated":"2023-11-18T04:42:14.960Z","comments":true,"path":"2022/05/07/Python+Docker实现人脸识别远程监控系统/","link":"","permalink":"http://zhongriqian.github.io/2022/05/07/Python+Docker%E5%AE%9E%E7%8E%B0%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E8%BF%9C%E7%A8%8B%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"说明本项目实现远程人脸识别监控功能，包括服务端程序和客户端程序。服务端使用Python OpenCV库实现人脸识别功能，将添加上识别结果的视频流通过TCP发送给客户端，且实现了Docker容器对上述功能的封装；客户端程序通过IP+端口接入服务端，接收视频流，实时查看人脸识别结果。客户端可与服务端断开接入后重新连接，不影响服务端功能。 项目文件 tcpsend.py（服务端程序） tcpreceive.py（客户端程序） requirements.txt（项目依赖） train.py（人脸识别模型训练程序） trainer.yml（人脸识别模型） haarcascade_frontalface_alt2.xml（分类器） Dockerfile（构建Docker镜像所需文件） 项目源码tcpsend.py1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import socketimport cv2import sysimport osimport numpy as npip###address = (&#x27;ip&#x27;, 5555) # 服务端地址和端口ser = socket.socket(socket.AF_INET, socket.SOCK_STREAM)ser.bind(address)ser.listen(5)# 阻塞式print(&#x27;waiting。。。&#x27;)conn, addr = ser.accept()print(&#x27;建立连接...&#x27;)print(&#x27;连接对象：&#x27;, addr)cap = cv2.VideoCapture(0)# cap = cv2.VideoCapture(0)frames_num=cap.get(7)print(&#x27;视频总帧数：&#x27;,frames_num)print(&#x27;发送目标...&#x27;)count = 0#######加载训练数据集文件recogizer = cv2.face.LBPHFaceRecognizer_create()recogizer.read(&#x27;./trainer.yml&#x27;)names = []warningtime = 0#准备识别的图片def face_detect_demo(img): gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) # 转换为灰度 face_detector = cv2.CascadeClassifier(&#x27;./haarcascade_frontalface_alt2.xml&#x27;) face = face_detector.detectMultiScale(gray, 1.1, 5, cv2.CASCADE_SCALE_IMAGE, (100, 100), (300, 300)) # face=face_detector.detectMultiScale(gray) for x, y, w, h in face: cv2.rectangle(img, (x, y), (x+w, y+h), color=(255, 144, 30), thickness=2) # blue,green,red # cv2.circle(img,center=(x+w//2,y+h//2),radius=w//2,color=(0,255,0),thickness=1) # 人脸识别 ids, confidence = recogizer.predict(gray[y:y + h, x:x + w]) # print(&#x27;标签id:&#x27;,ids,&#x27;置信评分：&#x27;, confidence) if confidence &gt; 80: cv2.putText(img, &#x27;unkonw&#x27;, (x + 10, y - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.75, (255, 144, 30), 2) else: cv2.putText(img, &#x27;dong&#x27;, (x + 10, y - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.75, (255, 144, 30), 2) # cv2.imshow(&#x27;result&#x27;, img) # print(&#x27;bug:&#x27;,ids) return imgdef name(): path = &#x27;./dataset/&#x27; # names = [] imagePaths = [os.path.join(path, f) for f in os.listdir(path)] for imagePath in imagePaths: name = str(os.path.split(imagePath)[1].split(&#x27;.&#x27;, 2)[1]) names.append(name)####name()while True: flag, frame = cap.read() frame = face_detect_demo(frame) # frame = cv2.resize(frame, (1280, 720)) # cv2.imshow(&#x27;send&#x27;, frame) cv2.waitKey(1) count += 1 # 数据打包有很多方式，也可以用json打包 img_encode = cv2.imencode(&#x27;.jpg&#x27;, frame)[1] data_encode = np.array(img_encode) str_encode = data_encode.tostring() try: conn.sendall(str_encode) except : conn, addr = ser.accept() tcpreceive.py123456789101112131415161718192021222324252627282930import socketimport sysimport cv2import numpy as npimport timeaddress = (&#x27;ip&#x27;, 5555) # 服务端地址和端口cli = socket.socket(socket.AF_INET, socket.SOCK_STREAM)try: cli.connect(address) # 尝试连接服务端except Exception:ip print(&#x27;[!] Server not found or not open&#x27;) sys.exit()frame_count = 1while True: time1 = time.time() if frame_count == 1 else time1 trigger = &#x27;ok&#x27; cli.sendall(trigger.encode()) data = cli.recv(1024*1024*20) image = np.frombuffer(data, np.uint8) image = cv2.imdecode(image, cv2.IMREAD_COLOR) try: cv2.imshow(&#x27;video&#x27;, image) except: continue cv2.waitKey(1) end_time = time.time() time2 = time.time() print(image.shape[:2], int(frame_count / (time2 - time1))) frame_count += 1cli.close() train.py12345678910111213141516171819202122232425262728import osimport cv2 as cvfrom PIL import Imageimport numpy as npdef getImageAndLabels(path): facesSamples = [] # 储存人脸数据 ids = [] # 尺寸姓名数据 imagePaths = [os.path.join(path, f) for f in os.listdir(path)] # 储存图片信息 face_detector = cv.CascadeClassifier(&#x27;D:/Python/python3.9.8/Lib/site-packages/cv2/data/haarcascade_frontalface_alt2.xml&#x27;) # 加载分类器 for imagePath in imagePaths: # 遍历列表中的图片 PIL_img = Image.open(imagePath).convert(&#x27;L&#x27;) # 打开图片，灰度化(PIL有九种模式：1,L,P,RGB,RGBA,CMYK,YCbCr,YCbCr,I,F) img_numpy = np.array(PIL_img, &#x27;uint8&#x27;) # 将图片转换为数组，以黑白深浅 faces = face_detector.detectMultiScale(img_numpy) # 获取图片人脸特征 id = int(os.path.split(imagePath)[1].split(&#x27;.&#x27;)[0]) # 获取每张图片的id和姓名 for x, y, w, h in faces: ids.append(id) facesSamples.append(img_numpy[y:y+h, x:x+w]) print(&#x27;id:&#x27;, id) print(&#x27;fs:&#x27;, facesSamples) return facesSamples, idsif __name__ == &#x27;__main__&#x27;: path = &#x27;./dataset/&#x27; # 图片路径 faces, ids = getImageAndLabels(path) # 获取图像数组和id标签数据和姓名 recognizer = cv.face.LBPHFaceRecognizer_create() # 加载识别器 recognizer.train(faces, np.array(ids)) # 训练 recognizer.write(&#x27;./trainer/trainer.yml&#x27;) # 保存文件 requirements.txt1234numpy==1.21.5Pillow==9.1.0opencv-contrib-python==4.5.5.64opencv-python==4.5.5.64 Dockerfile12345678FROM python:3.7-slimADD ./facerecognitionserver /codeWORKDIR /codeRUN apt-get updateRUN apt-get install -y libgl1-mesa-glxRUN apt-get install -y libglib2.0-devRUN pip install -r requirements.txtCMD [&quot;python&quot;,&quot;/code/tcpsend.py&quot;]","categories":[{"name":"Python","slug":"Python","permalink":"http://zhongriqian.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://zhongriqian.github.io/tags/Python/"},{"name":"Docker","slug":"Docker","permalink":"http://zhongriqian.github.io/tags/Docker/"},{"name":"OpenCV","slug":"OpenCV","permalink":"http://zhongriqian.github.io/tags/OpenCV/"},{"name":"Socket","slug":"Socket","permalink":"http://zhongriqian.github.io/tags/Socket/"}]},{"title":"Python爬取王蛇属蛇类科普网站数据","slug":"Python爬取王蛇属蛇类科普网站数据","date":"2022-03-20T16:00:00.000Z","updated":"2023-01-28T08:53:46.685Z","comments":true,"path":"2022/03/21/Python爬取王蛇属蛇类科普网站数据/","link":"","permalink":"http://zhongriqian.github.io/2022/03/21/Python%E7%88%AC%E5%8F%96%E7%8E%8B%E8%9B%87%E5%B1%9E%E8%9B%87%E7%B1%BB%E7%A7%91%E6%99%AE%E7%BD%91%E7%AB%99%E6%95%B0%E6%8D%AE/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import requestsfrom lxml import etreeimport reimport timeimport osfrom concurrent.futures import ThreadPoolExecutorfrom tqdm import tqdmdef mkdir(path): &quot;&quot;&quot; 创建文件夹 :param path: 文件夹路径 :return: &quot;&quot;&quot; folder = os.path.exists(path) if not folder: os.makedirs(path)def data_save(data): &quot;&quot;&quot; 下载图片并保存图片对应信息 :param data:从网页爬取的元组格式数据 :return: &quot;&quot;&quot; photo_url_all = &quot;https://sites.pitt.edu/~mcs2/herp/&quot; + data[3] # print(photo_url_all) # 获取图片页面内容 resp_photo_page = requests.get(photo_url_all) photo_page_content = resp_photo_page.text photo_page_content_html = etree.HTML(photo_page_content) # xpath获取图片页面内每张图片的下载地址 src = photo_page_content_html.xpath(&#x27;/html/body/p/img/@src&#x27;) # 获取要存放每组图片的文件夹名称，并创建对应名称的文件夹 folder_name = (data[3].split(&quot;/&quot;)[-1]).split(&quot;.&quot;)[0] mkdir(&quot;data/&quot; + folder_name) for itt in src: # 逐张保存 src = &quot;https://sites.pitt.edu/~mcs2/herp/&quot; + itt src_resp = requests.get(src) photo_name = src.split(&quot;/&quot;)[-1] with open(&quot;data/&quot; + folder_name + &#x27;/&#x27; + photo_name, mode=&#x27;wb&#x27;) as f: f.write(src_resp.content) time.sleep(1) # 创建每组图片的信息文本，并写入信息 with open(&quot;data/&quot; + folder_name + &#x27;/&#x27; + folder_name + &#x27;.txt&#x27;, mode=&#x27;a&#x27;) as ff: ff.write(&quot;Scientific Name : %s\\n&quot; % data[0]) ff.write(&quot;Common Name : %s\\n&quot; % data[1]) ff.write(&quot;Adult Length : %s\\n&quot; % data[2])if __name__ == &#x27;__main__&#x27;: url = &quot;https://sites.pitt.edu/~mcs2/herp/Lampropeltis.html&quot; resp = requests.get(url) page_content = resp.text obj = re.compile(r&#x27;&lt;/td&gt;.*?&lt;tr&gt;&#x27; r&#x27;.*?&lt;td nowrap valign = top&gt;(?P&lt;Scientific_Name&gt;.*?)&lt;/td&gt;&#x27; r&#x27;.*?&lt;td valign = top&gt;(?P&lt;Common_Name&gt;.*?)&lt;/td&gt;&#x27; r&#x27;.*?&lt;td nowrap align = right valign = top&gt;(?P&lt;Adult_Length&gt;.*?)&lt;/td&gt;&#x27; r&#x27;.*?&lt;td valign = top&gt;&lt;IMG SRC=&quot;.*?ball.gif&quot;&gt;\\s?&lt;A\\s+HREF=&quot;(?P&lt;Photo&gt;.*?)&quot;&gt;Photo&lt;/A&gt;&#x27;, re.S ) # 返回迭代器 # result = obj.finditer(page_content) # for it in result: # print(it.group(&quot;Scientific_Name&quot;)) # print(it.group(&quot;Common_Name&quot;)) # print(it.group(&quot;Adult_Length&quot;)) # print(it.group(&quot;Photo&quot;)) # 返回列表 result = obj.findall(page_content) # 多线程 # with ThreadPoolExecutor(30) as t: # for n in tqdm(result, &#x27;数据获取中&#x27;): # t.submit(data_save, n) # print(&quot;数据获取完成&quot;) # 单个依次获取 for n in tqdm(result, &#x27;数据获取中&#x27;): data_save(n) print(&quot;数据获取完成&quot;)","categories":[{"name":"Python","slug":"Python","permalink":"http://zhongriqian.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://zhongriqian.github.io/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://zhongriqian.github.io/tags/%E7%88%AC%E8%99%AB/"}]}],"categories":[{"name":"open vpn","slug":"open-vpn","permalink":"http://zhongriqian.github.io/categories/open-vpn/"},{"name":"EtherCAT","slug":"EtherCAT","permalink":"http://zhongriqian.github.io/categories/EtherCAT/"},{"name":"Linux","slug":"Linux","permalink":"http://zhongriqian.github.io/categories/Linux/"},{"name":"C","slug":"C","permalink":"http://zhongriqian.github.io/categories/C/"},{"name":"Docker","slug":"Docker","permalink":"http://zhongriqian.github.io/categories/Docker/"},{"name":"Python","slug":"Python","permalink":"http://zhongriqian.github.io/categories/Python/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://zhongriqian.github.io/tags/Linux/"},{"name":"vpn","slug":"vpn","permalink":"http://zhongriqian.github.io/tags/vpn/"},{"name":"NAT traversal","slug":"NAT-traversal","permalink":"http://zhongriqian.github.io/tags/NAT-traversal/"},{"name":"EtherCAT","slug":"EtherCAT","permalink":"http://zhongriqian.github.io/tags/EtherCAT/"},{"name":"VxLAN","slug":"VxLAN","permalink":"http://zhongriqian.github.io/tags/VxLAN/"},{"name":"C","slug":"C","permalink":"http://zhongriqian.github.io/tags/C/"},{"name":"Docker","slug":"Docker","permalink":"http://zhongriqian.github.io/tags/Docker/"},{"name":"Socket","slug":"Socket","permalink":"http://zhongriqian.github.io/tags/Socket/"},{"name":"Modbus RTU","slug":"Modbus-RTU","permalink":"http://zhongriqian.github.io/tags/Modbus-RTU/"},{"name":"MQTT","slug":"MQTT","permalink":"http://zhongriqian.github.io/tags/MQTT/"},{"name":"Python","slug":"Python","permalink":"http://zhongriqian.github.io/tags/Python/"},{"name":"5G","slug":"5G","permalink":"http://zhongriqian.github.io/tags/5G/"},{"name":"TBS","slug":"TBS","permalink":"http://zhongriqian.github.io/tags/TBS/"},{"name":"OpenCV","slug":"OpenCV","permalink":"http://zhongriqian.github.io/tags/OpenCV/"},{"name":"爬虫","slug":"爬虫","permalink":"http://zhongriqian.github.io/tags/%E7%88%AC%E8%99%AB/"}]}